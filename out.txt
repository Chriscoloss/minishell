
#include "./../../include/minishell.h"

// Function to handle 'cd -' case
void	cd_oldpwd(t_envlst **envp)
{
	char	*oldpwd;
	char	*current_pwd;

	current_pwd = getcwd(NULL, 0);
	if (!current_pwd)
		return (perror("getcwd"));
	oldpwd = my_getenv("OLDPWD", *envp);
	if (!oldpwd)
		return (free(current_pwd), (void)printf(ERR_OLDPWD));
	if (chdir(oldpwd) == -1)
	{
		free(current_pwd);
		printf("🍕🚀🌈🦄🍺: cd: %s: No such file or directory\n", oldpwd);
		return ;
	}
	printf("%s\n", oldpwd);
	change_env(&(*envp), "OLDPWD", current_pwd, 0);
	free(current_pwd);
	current_pwd = getcwd(NULL, 0);
	if (!current_pwd)
		return (perror("getcwd"));
	change_env(&(*envp), "PWD", current_pwd, 0);
	free(current_pwd);
}

// Function to handle changing to a specific path
void	cd_path(char *path, t_envlst **envp)
{
	char	*oldpwd;
	char	*pwd;

	oldpwd = getcwd(NULL, 0);
	if (!oldpwd)
		return (perror("getcwd"));
	if (chdir(path) == -1)
	{
		printf("🍕🚀🌈🦄🍺: cd: %s: No such file or directory\n", path);
		free(oldpwd);
		return ;
	}
	pwd = getcwd(NULL, 0);
	if (!pwd)
	{
		perror("getcwd");
		free(oldpwd);
		return ;
	}
	change_env(&(*envp), "OLDPWD", oldpwd, 0);
	change_env(&(*envp), "PWD", pwd, 0);
	free(oldpwd);
	free(pwd);
}

// Helper function to change the current working directory to the home directory
void	cd_home(t_envlst **envp)
{
	char	*home;
	char	*oldpwd;
	char	*pwd;

	home = getenv("HOME");
	if (!home)
		return ((void)printf("cd: HOME not set\n"));
	oldpwd = getcwd(NULL, 0);
	if (!oldpwd)
		return (perror("getcwd"));
	if (chdir(home) == -1)
	{
		printf("🚀: cd: %s: No such file or directory\n", home);
		free(oldpwd);
		return ;
	}
	pwd = getcwd(NULL, 0);
	if (!pwd)
		return (perror("getcwd"), free(oldpwd));
	change_env(&(*envp), "OLDPWD", oldpwd, 0);
	change_env(&(*envp), "PWD", pwd, 0);
	free(oldpwd);
}

// Main function that changes the current working directory
void	ft_cd(int argc, char **argv, t_envlst **envp)
{
	if (argc == 1 || !ft_strcmp(argv[1], "~") || !ft_strcmp(argv[1], "--"))
	{
		if (getenv("HOME"))
			return (cd_home(envp));
		else
			return ((void)printf("🍕🚀🌈🦄🍺: cd: HOME not set\n"));
	}
	if (argc == 2 && !ft_strcmp(argv[1], "-"))
		cd_oldpwd(envp);
	else if (argc == 2)
		cd_path(argv[1], envp);
}


#include "./../../include/minishell.h"

// Echo builtin
void	ft_echo(char **args)
{
	bool	newline;
	int		start_index;

	if (strcmp(args[0], "echo") == 0)
		start_index = handle_options(args, &newline, 1);
	else
		start_index = handle_options(args, &newline, 0);
	print_output(args, start_index, newline);
}

// Returns the index of the first argument that is not an option
int	handle_options(char **args, bool *newline, int start_index)
{
	int	i;
	int	j;

	*newline = true;
	i = start_index;
	while (args[i] && args[i][0] == '-' && args[i][1] == 'n')
	{
		j = 2;
		while (args[i][j] == 'n')
			j++;
		if (args[i][j] == '\0')
		{
			*newline = false;
			i++;
		}
		else
			break ;
	}
	return (i);
}

// Print output with or without newline
void	print_output(char **args, int start_index, bool newline)
{
	int	i;

	i = start_index;
	while (args[i])
	{
		printf("%s", args[i]);
		if (args[i + 1])
			printf(" ");
		i++;
	}
	if (newline)
		printf("\n");
}


#include "./../../include/minishell.h"

void	ft_env(t_envlst *env_list)
{
	t_envlst	*temp;

	temp = env_list;
	while (temp != NULL)
	{
		if (temp->value != NULL)
			ft_printf("%s=%s\n", temp->name, temp->value);
		temp = temp->next;
	}
}


#include "./../../include/minishell.h"

void	ft_exit(char **argv, t_minishell *m)
{
	if (argv[1])
	{
		if (m->exitcode == 0 && argv[1][0] != '0')
		{
			printf("🍕🚀🌈🦄🍺: exit: %s: %s\n",
				argv[1], NUMERIC_ARG_REQUIRED);
			exit(2);
		}
	}
	cleanup_minishell(m);
	exit(m->exitcode);
}


#include "./../../include/minishell.h"

// Recreates the expport behavior from bash
void	ft_export(int argc, char **argv, t_envlst **envp)
{
	int		i;
	char	**envp_export;

	i = 0;
	if (argc == 1 && ft_strcmp(argv[0], "export") == 0)
	{
		envp_export = copy_envp(*envp);
		sort_envp(envp_export);
		while (envp_export[i])
		{
			print_env_variable(envp_export[i]);
			free(envp_export[i++]);
		}
		free(envp_export);
	}
	else
		change_var_value(&(*envp), argv);
}

// Adds or updates the env variables in the envp list
void	my_export(t_envlst **envp, char **argv)
{
	int		i;
	char	*name;
	char	*value;

	i = 0;
	while (argv[i])
	{
		extract_name_value(argv[i], &name, &value);
		if (name)
			change_env(envp, name, value, 1);
		i++;
	}
}

// Adds or updates a node in the env list with the given name and value
// or deletes it if value is NULL and free_it is 1
void	change_env(t_envlst **env_lst, char *key, char *value, int free_it)
{
	t_envlst	*current;

	current = *env_lst;
	while (current)
	{
		if (ft_strcmp(current->name, key) == 0)
		{
			free(current->value);
			if (value)
				current->value = ft_strdup(value);
			else
				current->value = NULL;
			if (free_it)
			{
				free(key);
				free(value);
			}
			return ;
		}
		current = current->next;
	}
	add_env_node(env_lst, key, value);
}

// Sorts a char ** array of env variables alphabetically
void	sort_envp(char **envp)
{
	int		i;
	int		j;
	char	*temp;

	i = 0;
	while (envp[i])
	{
		j = i + 1;
		while (envp[j])
		{
			if (ft_strcmp(envp[i], envp[j]) > 0)
			{
				temp = envp[i];
				envp[i] = envp[j];
				envp[j] = temp;
			}
			j++;
		}
		i++;
	}
}

// copies the envp array to a new array to avoid modifying the original
char	**copy_envp(t_envlst *envp)
{
	int		i;
	int		count;
	char	**envp_copy;
	char	*name_equals;

	i = 0;
	count = count_list(envp);
	envp_copy = malloc(sizeof(char *) * (count + 1));
	if (!envp_copy)
		return (NULL);
	while (envp)
	{
		if (envp->value)
		{
			name_equals = ft_strjoin(envp->name, "=");
			envp_copy[i] = ft_strjoin(name_equals, envp->value);
			free(name_equals);
		}
		else
			envp_copy[i] = ft_strdup(envp->name);
		envp = envp->next;
		i++;
	}
	envp_copy[i] = NULL;
	return (envp_copy);
}


#include "./../../include/minishell.h"

void	ft_pwd(char **args)
{
	char	*pwd;

	(void)args;
	pwd = getcwd(NULL, 0);
	if (pwd == NULL)
		return ;
	ft_printf("%s\n", pwd);
	free(pwd);
}


#include "./../../include/minishell.h"

// Function that changes the value of a variable
void	change_var_value(t_envlst **envp, char **argv)
{
	int			i;
	t_envlst	*current;
	char		*temp;

	i = 0;
	if (ft_strcmp(argv[0], "export") == 0)
		i++;
	while (argv[i])
	{
		current = *envp;
		while (ft_strncmp(current->name, argv[i], ft_strlen(current->name))
			&& current->next != NULL)
			current = current->next;
		temp = ft_strjoin(current->name, "+=");
		if (!(ft_strncmp(argv[i], temp, ft_strlen(temp))))
			upgrade_var_value(envp, argv[i]);
		else
		{
			my_export(envp, &argv[i]);
		}
		free(temp);
		i++;
	}
}

// Function that upgrades the value of a variable
void	upgrade_var_value(t_envlst **envp, char *str)
{
	t_envlst	*current;
	char		*name;
	char		*value;
	char		*temp;
	char		*temp2;

	extract_name_value(str, &name, &value);
	current = *envp;
	while (ft_strncmp(current->name, name, ft_strlen(current->name))
		&& current->next != NULL)
		current = current->next;
	temp = ft_strjoin(current->value, value);
	temp2 = ft_strtrim(temp, """");
	free(current->value);
	free(temp);
	current->value = temp2;
}

// Function that updates the value of a variable
void	update_var_value(t_envlst **envp, char *str)
{
	t_envlst	*current;
	char		*name;
	char		*value;

	extract_name_value(str, &name, &value);
	current = *envp;
	while (ft_strncmp(current->name, name, ft_strlen(current->name))
		&& current->next != NULL)
		current = current->next;
	free(current->value);
	current->value = value;
}


#include "./../../include/minishell.h"

// Function to remove an environment variable from envp
void	ft_unset(t_envlst **envp, char **argv)
{
	t_envlst	*tmp;
	t_envlst	*prev;
	int			i;

	i = 1;
	while (argv[i])
	{
		tmp = *envp;
		prev = NULL;
		while (tmp)
		{
			if (ft_strcmp(tmp->name, argv[i]) == 0)
			{
				if (prev)
					prev->next = tmp->next;
				else
					*envp = tmp->next;
				free_envlst_node(tmp);
				break ;
			}
			prev = tmp;
			tmp = tmp->next;
		}
		i++;
	}
}

// Function to free the memory of an envlst node
void	free_envlst_node(t_envlst *node)
{
	if (ft_strcmp(node->name, "OLDPWD") == 0)
		return ;
	free(node->name);
	free(node->value);
	free(node);
}


#include "./../../include/minishell.h"

// Counts the number of elements in the envp list
int	count_list(t_envlst *envp)
{
	int	count;

	count = 0;
	while (envp)
	{
		envp = envp->next;
		count++;
	}
	return (count);
}

// Prints the env variable in the format "declare -x NAME="VALUE"
void	print_env_variable(const char *envar)
{
	const char	*equal_sign;
	size_t		namelen;

	equal_sign = ft_strchr(envar, '=');
	if (equal_sign != NULL)
	{
		namelen = equal_sign - envar;
		printf("declare -x %.*s=\"%s\"\n", (int)namelen,
			envar, equal_sign + 1);
	}
	else
		printf("declare -x %s\n", envar);
}

// Funktion returned 0 wenn argv[0] mir einem Variablennamen überein stimmt
int	is_var_name(t_envlst *envp, char **argv)
{
	t_envlst	*current;

	current = envp;
	while (current != NULL)
	{
		if (!(ft_strncmp(current->name, argv[0], ft_strlen(current->name))))
			return (0);
		current = current->next;
	}
	return (1);
}

char	*my_getenv(const char *name, t_envlst *envp)
{
	while (envp)
	{
		if (ft_strcmp(name, envp->name) == 0)
			return (envp->value);
		envp = envp->next;
	}
	return (NULL);
}

// Behaves like the strndup function from the standard library
char	*ft_strndup(const char *s, size_t n)
{
	size_t	i;
	size_t	len;
	char	*result;

	i = 0;
	len = 0;
	while (len < n && s[len] != '\0')
		len++;
	result = (char *)malloc(len + 1);
	if (result == NULL)
		return (NULL);
	while (i < len)
	{
		result[i] = s[i];
		i++;
	}
	result[len] = '\0';
	return (result);
}


#include "./../../include/minishell.h"

int	allocate_pids(t_minishell *m, int pipes)
{
	m->pids = malloc(sizeof(pid_t) * (pipes + 1));
	if (!m->pids)
	{
		ft_fprintf(2, "Memory allocation failed\n");
		return (0);
	}
	return (1);
}

int	fork_and_execute(t_minishell *m, t_pipe_info *pi)
{
	m->pids[pi->i] = fork();
	if (m->pids[pi->i] == 0)
	{
		run_child_process(m, pi);
		write(1, "fork\n", 5);
		exit(1);
	}
	else if (m->pids[pi->i] < 0)
	{
		ft_fprintf(2, "Fork failed\n");
		return (0);
	}
	return (1);
}
// Neue Hilfsfunktion
int has_pipes(t_list *tok_lst)
{
    t_list *current = tok_lst;
    while (current)
    {
        t_token *token = (t_token *)current->content;
        if (token->token == PIPE)
            return 1;
        current = current->next;
    }
    return 0;
}


void execute(t_minishell *m)
{
	int i;
	
	i = 0;
	while(i < MAXPIPS)
	{
		m->cmd_seqs[i] = NULL;
		i++;
	}
	i = 0;
	while(i < MAXPIPS)
	{
		m->exec_seqs[i] = NULL;
		i++;
	}
	i = 0;
	while(i < MAXPIPS)
	{
		m->args[i] = NULL;
		i++;
	}
	m->last_exitcode = m->exitcode;
	m->exitcode = 0;
	
	m->pipes = 0;
	if (has_pipes(m->tok_lst))
	{
		split_pipes(m);
	    execute_with_pipes(m);
	    reset_minishell_args(m);
		cleanup_minishell(m);
	}
	else
	{
		prexecute(m, 0);
		if (g_global == 0)
			run_seg(m, 0, STDIN_FILENO, STDOUT_FILENO);
		reset_minishell_args(m);
		if (m->tok_lst)
		{
			mlstclear(m->tok_lst);
			m->tok_lst = NULL;
		}
		if (m->exec_lst)
		{
			mlstclear(m->exec_lst);
			m->exec_lst = NULL;
		}
	}
}


#include "./../../include/minishell.h"

int	check_one(t_minishell *m, enum e_toktype lty, enum e_toktype conty)
{
	if (!m->leave && lty == PIPE && conty == PIPE)
		return (1);
	return (0);
}

int	check_two(t_minishell *m, enum e_toktype conty, enum e_toktype end)
{
	if (!m->leave && conty == PIPE && end == UNSET)
		return (1);
	return (0);
}

int	check_three(t_minishell *m, t_list *curnext, enum e_toktype conty)
{
	if (!m->leave && curnext == NULL && conty == PIPE)
		return (1);
	return (0);
}

int	check_four(t_minishell *m, enum e_toktype conty, enum e_toktype end)
{
	if (!m->leave && conty == PIPE && end == REDIRECTION)
		return (1);
	return (0);
}

int	check_five(t_minishell *m, t_list *curnext, enum e_toktype conty)
{
	if (!m->leave && curnext == NULL && conty == REDIRECTION)
		return (1);
	return (0);
}


#include "./../../include/minishell.h"

int	check_six(t_minishell *m, enum e_toktype end, enum e_toktype conty)
{
	if (!m->leave && end == REDIRECTION && conty == REDIRECTION)
		return (1);
	return (0);
}


#include "./../../include/minishell.h"

static void	check_rdrc_norm(char *last_str, t_token *cont, t_minishell *m)
{
	if ((!ft_strcmp(last_str, "<<") || !ft_strcmp(last_str, ">>"))
		&& !ft_strcmp(cont->str, ">"))
		pic_err(m, 2, SYN_ERR_GT);
	if ((!ft_strcmp(last_str, "<<") || !ft_strcmp(last_str, ">>"))
		&& !ft_strcmp(cont->str, ">>"))
		pic_err(m, 2, SYN_ERR_DBL_GT);
	if ((!ft_strcmp(last_str, "<<") || !ft_strcmp(last_str, ">>"))
		&& !ft_strcmp(cont->str, "<"))
		pic_err(m, 2, SYN_ERR_LT);
	if ((!ft_strcmp(last_str, "<<") || !ft_strcmp(last_str, ">>"))
		&& !ft_strcmp(cont->str, "<<"))
		pic_err(m, 2, SYN_ERR_DBL_LT);
}

static void	check_pipes(t_minishell *m)
{
	t_list			*cur;
	t_token			*cont;
	enum e_toktype	end;
	enum e_toktype	ltype;

	end = UNSET;
	ltype = UNSET;
	cur = m->tok_lst;
	while (cur != NULL)
	{
		cont = (t_token *)cur->content;
		if (check_one(m, ltype, cont->token))
			pic_err(m, 2, SYN_ERR_PIPE);
		else if (check_two(m, cont->token, end))
			pic_err(m, 2, SYN_ERR_PIPE);
		else if (check_three(m, cur->next, cont->token))
			pic_err(m, 2, SYN_ERR_NEWLINE);
		end = cont->token;
		ltype = cont->token;
		cur = cur->next;
	}
}

static void	check_rdrcmeta(t_list *last, t_list *current, t_token *token)
{
	init_semantics(last, current);
	if (token->token == REDIRECTION)
	{
		if (ft_strcmp(token->str, "<<") == 0)
			token->rdrcmeta = ft_strdup("here_doc");
		if (ft_strcmp(token->str, ">>") == 0)
		{
			token->rdrcmeta = ft_strdup("append");
			update_tok_type_next_word(current, MINIFILE);
		}
		if (ft_strcmp(token->str, "<") == 0)
		{
			token->rdrcmeta = ft_strdup("redirection");
			update_tok_type_next_word(current, MINIFILE);
		}
		if (ft_strcmp(token->str, ">") == 0)
		{
			token->rdrcmeta = ft_strdup("truncate");
			update_tok_type_next_word(current, MINIFILE);
		}
	}
}

static void	check_redirections(t_minishell *m)
{
	t_list			*cur;
	t_list			*last;
	t_token			*cont;
	enum e_toktype	end;
	char			*last_str;

	last = NULL;
	end = UNSET;
	last_str = NULL;
	cur = m->tok_lst;
	while (cur != NULL)
	{
		cont = (t_token *)cur->content;
		if (check_four(m, cont->token, end))
			pic_err(m, 2, SYN_ERR_PIPE);
		else if (check_five(m, cur->next, cont->token))
			pic_err(m, 2, SYN_ERR_NEWLINE);
		else if (check_six(m, end, cont->token))
			check_rdrc_norm(last_str, cont, m);
		check_rdrcmeta(last, cur, cont);
		end = cont->token;
		last_str = cont->str;
		last = cur;
		cur = cur->next;
	}
}

void	pre_exec_checks(t_minishell *m)
{
	if (!m->leave)
		check_pipes(m);
	if (!m->leave)
		check_redirections(m);
}


#include "./../../include/minishell.h"

int	is_builtin(char *command)
{
	return (!ft_strcmp(command, "cd")
		|| !ft_strcmp(command, "echo")
		|| !ft_strcmp(command, "env")
		|| !ft_strcmp(command, "exit")
		|| !ft_strcmp(command, "export")
		|| !ft_strcmp(command, "pwd")
		|| !ft_strcmp(command, "unset"));
}

void	execute_builtin(t_minishell *m, char *com, char **argv, int argc)
{
	if (!ft_strcmp(com, "cd"))
		ft_cd(argc, argv, &m->env_list);
	else if (!ft_strcmp(com, "echo"))
		ft_echo(argv);
	else if (!ft_strcmp(com, "env"))
		ft_env(m->env_list);
	else if (!ft_strcmp(com, "exit"))
		ft_exit(argv, m);
	else if (!ft_strcmp(com, "export"))
		ft_export(argc, argv, &m->env_list);
	else if (!ft_strcmp(com, "pwd"))
		ft_pwd(argv);
	else if (!ft_strcmp(com, "unset"))
		ft_unset(&m->env_list, argv);
}

void	cleanup(char **argv)
{
	int	i;

	i = 0;
	while (argv[i] != NULL)
		free(argv[i++]);
	free(argv);
}

int	is_word_token(t_list *node)
{
	t_token	*token;

	token = (t_token *)node->content;
	return (token->token == WORD);
}

int	resize_argv(char ***argv, int *capacity)
{
	char	**new_argv;
	int		i;

	*capacity *= 2;
	new_argv = (char **)ft_calloc(*capacity + 1, sizeof(char *));
	if (!new_argv)
		return (cleanup(*argv), 0);
	i = 0;
	while ((*argv)[i] != NULL)
	{
		new_argv[i] = (*argv)[i];
		i++;
	}
	free(*argv);
	*argv = new_argv;
	return (1);
}


#include "./../../include/minishell.h"

char	**allocate_env_array(size_t count)
{
	return ((char **)malloc(sizeof(char *) * (count + 1)));
}

char	*create_env_entry(const char *name, const char *value)
{
	char	*tmp;
	char	*env_entry;

	tmp = ft_strjoin(name, "=");
	if (!tmp)
		return (NULL);
	env_entry = ft_strjoin(tmp, value);
	free(tmp);
	return (env_entry);
}

void	free_env_array(char **env)
{
	size_t	i;

	i = 0;
	while (env[i])
	{
		free(env[i]);
		i++;
	}
	free(env);
}

int	populate_env_array(char **env, t_envlst *env_lst)
{
	size_t	k;
	char	*env_entry;

	k = 0;
	while (env_lst != NULL)
	{
		if (env_lst->value != NULL)
		{
			env_entry = create_env_entry(env_lst->name, env_lst->value);
			if (!env_entry)
			{
				free_env_array(env);
				return (0);
			}
			env[k++] = env_entry;
		}
		env_lst = env_lst->next;
	}
	env[k] = NULL;
	return (1);
}

char	**own_env(t_envlst *env_lst)
{
	char	**env;
	size_t	env_count;

	env_count = count_list(env_lst);
	env = allocate_env_array(env_count);
	if (!env)
		return (NULL);
	if (!populate_env_array(env, env_lst))
	{
		free_env_array(env);
		return (NULL);
	}
	return (env);
}


#include "./../../include/minishell.h"

static char	*find_executable(char **paths, int pathcount, char *command)
{
	int		i;
	char	*joined;
	char	*full_path;

	i = 0;
	while (i < pathcount)
	{
		full_path = ft_strjoin(paths[i], "/");
		if (full_path == NULL)
			return (NULL);
		joined = ft_strjoin(full_path, command);
		free(full_path);
		if (joined == NULL)
			return (NULL);
		if (access(joined, X_OK) == 0)
			return (joined);
		free(joined);
		i++;
	}
	return (NULL);
}

void	newfree_token(t_token *token)
{
	if (token)
	{
		if (token->str)
		{
        	free(token->str);
			token->str = NULL;
		}
		if (token->expmap)
		{
        	free(token->expmap);
			token->expmap = NULL;
		}
		if (token->rdrcmeta)
		{
        	free(token->rdrcmeta);
			token->rdrcmeta = NULL;
		}
		if (token->rdrctarget)
		{
        	free(token->rdrctarget);
			token->rdrctarget = NULL;
		}
		free(token);
		token = NULL;
	}
}

char	*get_executable(t_minishell *m, char *command)
{
	char	*pathline;
	char	**paths;
	int		pathcount;
	char	*result;

	if (ft_strchr(command, '/') && access(command, F_OK) == 0)
		return (ft_strdup(command));
	pathline = my_getenv("PATH", m->env_list);
	if (pathline != NULL)
	{
		pathcount = ft_count_words(pathline, ':');
		paths = ft_split(pathline, ':');
		if (paths == NULL)
			return (NULL);
		result = find_executable(paths, pathcount, command);
		ft_array_l_free(paths, pathcount);
		return (result);
	}
	return (NULL);
}

void	execute_command(t_minishell *m, char *executable, char **argv)
{
	char	**own;

	own = own_env(m->env_list);
	if (is_builtin(executable))
		execute_builtin(m, executable, argv, ft_array_length(argv));
	else
	{
		execve(executable, argv, own);
		perror("execve failed");
		free(executable);
		write(1, "cmds\n", 5);
		exit(EXIT_FAILURE);
	}
}

int	keep_for_exec(t_token *token)
{
	if (token->token == WORD || token->token == COMMAND || token->token == PIPE)
		return (1);
	return (0);
}


#include "./../../include/minishell.h"

void	ft_error_exit(const char *message)
{
	perror(message);
	exit(EXIT_FAILURE);
}

void	pic_err(t_minishell *m, int code, char *mes)
{
	ft_fprintf(2, "%s\n", mes);
	m->leave = 1;
	m->exitcode = code;
}

char	*get_last_cmd(t_list *ref, t_list *item)
{
	t_list	*current;
	t_token	*cur_content;
	char	*last_cmd;

	last_cmd = NULL;
	current = ref;
	while (current != NULL && current != item)
	{
		cur_content = (t_token *)current->content;
		if (cur_content != NULL)
		{
			if (cur_content->token == COMMAND)
			{
				last_cmd = cur_content->str;
			}
		}
		current = current->next;
	}
	return (last_cmd);
}

int	add_arg(char ***argv, int *capacity, t_list *temp, int *argc)
{
	t_token	*token;

	if (*argc >= *capacity)
		if (!resize_argv(argv, capacity))
			return (0);
	token = (t_token *)temp->content;
	(*argv)[*argc] = ft_strdup(token->str);
	if (!(*argv)[*argc])
	{
		cleanup(*argv);
		return (0);
	}
	(*argc)++;
	return (1);
}

int	add_first_arg(char **argv, t_list *current, int *argc)
{
	t_token	*token;

	token = (t_token *)current->content;
	argv[0] = ft_strdup(token->str);
	if (!argv[0])
	{
		free(argv);
		return (0);
	}
	*argc = 1;
	return (1);
}


#include "./../../include/minishell.h"

static t_token	*init_redirection_details(t_token *redirectiontoken)
{
	redirectiontoken->rdrcmeta = NULL;
	redirectiontoken->rdrctarget = NULL;
	return (redirectiontoken);
}

void	init_semantics(t_list *last, t_list *current)
{
	t_token	*last_token;
	t_token	*token;

	last_token = NULL;
	token = (t_token *)current->content;
	if (last)
	{
		last_token = (t_token *)last->content;
		if (token->token == WORD
			&& last_token->token == REDIRECTION
			&& !ft_strcmp(last_token->str, "<<"))
		{
			update_tok_type(token, DELIMITER);
			update_tok_type_next_word(current, COMMAND);
		}
		if (token->token == WORD
			&& last_token->token == PIPE
			&& !ft_strcmp(last_token->str, "|"))
			update_tok_type(token, COMMAND);
	}
	else
		if (token->token == WORD)
			update_tok_type(token, COMMAND);
}

void	pre_exec_prep(t_minishell *m)
{
	t_list	*current;
	t_token	*cur_content;

	current = m->tok_lst;
	while (current != NULL)
	{
		cur_content = (t_token *)current->content;
		if (cur_content->token == REDIRECTION)
			init_redirection_details(cur_content);
		current = current->next;
	}
}

void	init_fd(t_fd *fd, int input_fd, int output_fd)
{
	fd->input = input_fd;
	fd->output = output_fd;
	fd->last_input = input_fd;
	fd->last_output = output_fd;
}


#include "./../../include/minishell.h"

static void	setup_pipes(t_pipe_info *pi)
{
	if (pi->i < pi->total)
	{
		if (pipe(pi->pipe_fd) == -1)
		{
			ft_fprintf(2, "Pipe creation failed\n");
			return ;
		}
	}
	else
	{
		pi->pipe_fd[1] = STDOUT_FILENO;
	}
}

static int	process_pipecommand(t_minishell *m, t_pipe_info *pi)
{
	prexecute(m, pi->i);
	if (g_global == 0)
	{
		setup_pipes(pi);
		signal(SIGINT, SIG_IGN);
		signal(SIGQUIT, SIG_IGN);
		if (!fork_and_execute(m, pi))
		{
			return (0);
		}
		handle_parent_process(pi);
	}
	return (1);
}

void	execute_with_pipes(t_minishell *m)
{
	t_pipe_info	pi;

	pi.prv_pipe = STDIN_FILENO;
	pi.i = 0;
	pi.total = m->pipes;
	if (!allocate_pids(m, m->pipes))
		return ;
	while (m->cmd_seqs[pi.i] != NULL)
	{
		if (!process_pipecommand(m, &pi))
		{
			free(m->pids);
			m->pids = NULL;
			return ;
		}
		reset_minishell_args(m);
		pi.i++;
	}
	wait_for_children(m, &pi);
	free(m->pids);
	m->pids = NULL;
}


#include "./../../include/minishell.h"

t_token	*duplicate(t_token *src)
{
	t_token	*ne;

	ne = malloc(sizeof(t_token));
	if (!ne)
		return (NULL);
	*ne = *src;
	ne->str = ft_strdup(src->str);
	ne->expmap = ft_strdup(src->expmap);
	if (src->rdrcmeta)
		ne->rdrcmeta = ft_strdup(src->rdrcmeta);
	else
		ne->rdrcmeta = NULL;
	if (src->rdrctarget)
		ne->rdrctarget = ft_strdup(src->rdrctarget);
	else
		ne->rdrctarget = NULL;
	if (!ne->str || !ne->expmap
		|| (src->rdrcmeta && !ne->rdrcmeta)
		|| (src->rdrctarget && !ne->rdrctarget))
	{
		free(ne->expmap);
		free(ne->rdrcmeta);
		return (free(ne->str), free(ne->rdrctarget), free(ne), NULL);
	}
	return (ne);
}

static void	prex_ins(t_minishell *m, t_list *tok_lst, t_list **exec_lst)
{
	t_list	*current;
	t_token	*token;
	t_token	*ne;

	current = tok_lst;
	while (current != NULL)
	{
		token = (t_token *)current->content;
		if (!ft_strcmp(token->str, "<<"))
		{
			handle_heredoc(m, current);
			ne = duplicate(token);
			ft_lstadd_back(exec_lst, ft_lstnew(ne));
		}
		else if (!ft_strcmp(token->str, "<"))
		{
			handle_infile(current);
			ne = duplicate(token);
			ft_lstadd_back(exec_lst, ft_lstnew(ne));
		}
		current = current->next;
	}
}

static void	prex_mains(t_list *tok_lst, t_list **exec_lst)
{
	t_list	*current;
	t_token	*token;
	t_token	*ne;

	current = tok_lst;
	while (current != NULL)
	{
		token = (t_token *)current->content;
		if (keep_for_exec(token))
		{
			ne = duplicate(token);
			ft_lstadd_back(exec_lst, ft_lstnew(ne));
		}
		current = current->next;
	}
}

static void	prex_outs(t_list *tok_lst, t_list **exec_lst)
{
	t_list	*current;
	t_token	*token;
	t_token	*ne;

	current = tok_lst;
	while (current != NULL)
	{
		token = (t_token *)current->content;
		if (!ft_strcmp(token->str, ">") || !ft_strcmp(token->str, ">>"))
		{
			handle_trunc_append(current);
			ne = duplicate(token);
			ft_lstadd_back(exec_lst, ft_lstnew(ne));
		}
		current = current->next;
	}
}

void	prexecute(t_minishell *m, int i)
{
	if (m->exec_lst)
	{
		mlstclear(m->exec_lst);
		m->exec_lst = NULL;
	}
	if (m->pipes == 0)
	{
		prex_ins(m, m->tok_lst, &(m->exec_lst));
		prex_mains(m->tok_lst, &(m->exec_lst));
		prex_outs(m->tok_lst, &(m->exec_lst));
	}
	else
	{
		prex_ins(m, m->cmd_seqs[i], &(m->exec_seqs[i]));
		prex_mains(m->cmd_seqs[i], &(m->exec_seqs[i]));
		prex_outs(m->cmd_seqs[i], &(m->exec_seqs[i]));
	}
}


#include "./../../include/minishell.h"

void	run_in_redirection(t_token *token, t_fd *fd)
{
	if (fd->last_input != fd->input)
		close(fd->last_input);
	fd->last_input = open(token->rdrcmeta, O_RDONLY);
	if (fd->last_input == -1)
	{
		ft_fprintf(2, "Error input file: %s\n", token->rdrcmeta);
		return ;
	}
}

void	run_out_redirection(t_token *token, t_fd *fd)
{
	int	flags;

	if (fd->last_output != fd->output)
		close(fd->last_output);
	if (ft_strcmp(token->str, ">") == 0)
		flags = O_WRONLY | O_CREAT | O_TRUNC;
	else
		flags = O_WRONLY | O_CREAT | O_APPEND;
	fd->last_output = open(token->rdrctarget, flags, 0644);
	if (fd->last_output == -1)
	{
		ft_fprintf(2, "Error output file: %s\n", token->rdrctarget);
		return ;
	}
}

void	run_redirection(t_token *t, t_fd *fd)
{
	if (ft_strcmp(t->str, "<<") == 0)
		run_heredoc(t, fd);
	else if (ft_strcmp(t->str, "<") == 0)
		run_in_redirection(t, fd);
	else if (ft_strcmp(t->str, ">") == 0 || ft_strcmp(t->str, ">>") == 0)
		run_out_redirection(t, fd);
}


#include "./../../include/minishell.h"

void	run_heredoc(t_token *t, t_fd *fd)
{
	int	hd[2];

	if (pipe(hd) == -1)
	{
		ft_fprintf(2, "Error creating pipe for heredoc\n");
		return ;
	}
	write(hd[1], t->rdrcmeta, ft_strlen(t->rdrcmeta));
	close(hd[1]);
	if (fd->last_input != fd->input)
		close(fd->last_input);
	fd->last_input = hd[0];
}

void	run_command(t_minishell *m, char **args)
{
	char	*path;

	path = get_executable(m, args[0]);
	if (path)
	{
		execute_command(m, path, args);
		free(path);
	}
	ft_fprintf(2, "bash: %s: command not found\n", args[0]);
}

void	run(t_minishell *m, char **args, int arg_count, t_fd *fd)
{
	if (is_builtin(args[0]))
		exec_builtin_cmd(m, args, arg_count, fd);
	else
		execute_external_command(m, args, fd);
}

void	cleanup_fds(t_fd *fd)
{
	if (fd->last_input != fd->input)
		close(fd->last_input);
	if (fd->last_output != fd->output)
		close(fd->last_output);
}

void	print_token_pointers3(t_list *tok_lst)
{
	t_list	*current;
	t_token	*c;

	ft_printf("\n"Y"AFTER RUN: Token Pointers:"D"\n");
	current = tok_lst;
	while (current != NULL)
	{
		c = (t_token *)current->content;
		ft_printf("Token address: %p\n", c);
		ft_printf("Token->str: %p (%s)\n", c->str, c->str);
		ft_printf("Token->expmap: %p (%s)\n", c->expmap, c->expmap);
		current = current->next;
	}
	ft_printf(Y"End of token pointers\n"D);
}

void	run_seg(t_minishell *m, int i, int input_fd, int output_fd)
{
	t_fd	fd;

	init_fd(&fd, input_fd, output_fd);
	if (m->pipes == 0)
		process_tok(m, m->exec_lst, &fd);
	else
		process_tok(m, m->exec_seqs[i], &fd);
	if (m->args[0])
		run(m, m->args, m->argc, &fd);
	reset_minishell_args(m);
	cleanup_fds(&fd);
}


#include "./../../include/minishell.h"

void	add_argument(t_minishell *m, char *arg)
{
	int	i;

	i = 0;
	while (i < 1024)
	{
		if (m->args[i] == NULL)
		{
			m->args[i] = arg;
			break ;
		}
		i++;
	}
	if (i == 1024)
		ft_fprintf(2, "Error: Maximum number of arguments reached\n");
}

void	exec_builtin_cmd(t_minishell *m, char **args, int arg_count, t_fd *fd)
{
	if (fd->last_input != fd->input)
		dup2(fd->last_input, STDIN_FILENO);
	if (fd->last_output != fd->output)
		dup2(fd->last_output, STDOUT_FILENO);
	execute_builtin(m, args[0], args, arg_count);
}

void	execute_command_in_child(char *e, char **args, t_minishell *m, t_fd *fd)
{
	setup_child_process(fd);
	if (execve(e, args, m->envp) == -1)
	{
		ft_fprintf(2, "execve failed\n");
		exit(1);
	}
}

void	execute_external_command(t_minishell *m, char **args, t_fd *fd)
{
	pid_t	pid;
	char	*tmp;

	tmp = get_executable(m, args[0]);
	if (!tmp)
	{
		ft_fprintf(2, "bash: %s: Command not found\n", args[0]);
		m->exitcode = 127;
		return ;
	}
	signal(SIGINT, SIG_IGN);
	signal(SIGQUIT, SIG_IGN);
	pid = fork();
	if (pid == 0)
		execute_command_in_child(tmp, args, m, fd);
	else if (pid < 0)
	{
		ft_fprintf(2, "Fork failed\n");
		m->exitcode = 1;
	}
	else
	{
		run_parent_process(m, pid);
	}
	free(tmp);
}

void	process_tok(t_minishell *m, t_list *exec_lst, t_fd *fd)
{
	t_list	*current;
	t_token	*token;
	char	*dup_str;

	current = exec_lst;
	m->argc = 0;
	while (current != NULL)
	{
		token = (t_token *)current->content;
		if (token->token == REDIRECTION)
			run_redirection(token, fd);
		else if (token->token == COMMAND || token->token == WORD)
		{
			dup_str = ft_strdup(token->str);
			if (!dup_str)
			{
				ft_fprintf(2, "Error: Memory allocation failed\n");
				return ;
			}
			add_argument(m, dup_str);
			m->argc++;
		}
		current = current->next;
	}
}


#include "./../../include/minishell.h"

void	run_child_process(t_minishell *m, t_pipe_info *pi)
{
	signal(SIGINT, handle_child_process);
	signal(SIGQUIT, handle_child_process);
	if (pi->i > 0)
	{
		dup2(pi->prv_pipe, STDIN_FILENO);
		close(pi->prv_pipe);
	}
	if (m->cmd_seqs[pi->i + 1] != NULL)
	{
		close(pi->pipe_fd[0]);
		dup2(pi->pipe_fd[1], STDOUT_FILENO);
		close(pi->pipe_fd[1]);
	}
	run_seg(m, pi->i, STDIN_FILENO, STDOUT_FILENO);
	cleanup_minishell(m);
	ft_printf("Exiting reset_sequences\n");
	exit(0);
}

void	handle_parent_process(t_pipe_info *pi)
{
	if (pi->i > 0)
		close(pi->prv_pipe);
	if (pi->i < pi->total)
	{
		close(pi->pipe_fd[1]);
		pi->prv_pipe = pi->pipe_fd[0];
	}
}

void	wait_for_children(t_minishell *m, t_pipe_info *pi)
{
	int	j;
	int	status;

	j = 0;
	while (j < pi->i)
	{
		waitpid(m->pids[j], &status, 0);
		signal(SIGINT, handle_main_process);
		signal(SIGQUIT, handle_main_process);
		if (WIFEXITED(status))
			m->exitcode = WEXITSTATUS(status);
		else if (WIFSIGNALED(status))
			m->exitcode = 128 + WTERMSIG(status);
		j++;
	}
}

void	setup_child_process(t_fd *fd)
{
	signal(SIGINT, handle_child_process);
	signal(SIGQUIT, handle_child_process);
	if (fd->last_input != fd->input)
	{
		dup2(fd->last_input, STDIN_FILENO);
		close(fd->last_input);
	}
	if (fd->last_output != fd->output)
	{
		dup2(fd->last_output, STDOUT_FILENO);
		close(fd->last_output);
	}
}

void	run_parent_process(t_minishell *m, pid_t pid)
{
	int	status;

	waitpid(pid, &status, 0);
	signal(SIGINT, handle_main_process);
	signal(SIGQUIT, handle_main_process);
	if (WIFEXITED(status))
		m->exitcode = WEXITSTATUS(status);
	else if (WIFSIGNALED(status))
		m->exitcode = 128 + WTERMSIG(status);
}


#include "./../../include/minishell.h"

void	expand(t_exp_p *p, t_expand_ctx *ctx)
{
	char				*res;
	char				*exp_res;
	size_t				i;
	int					escaped;
	t_expand_data		data;

	i = p->start;
	escaped = 0;
	data = (t_expand_data){&res, &exp_res, p->str, p->expmap, &i, &escaped, p};
	if (initialize_expansion(&data) == -1)
		return ;
	ctx = &((t_expand_ctx){p->m, &res, &exp_res, p->str, p->expmap, &i, 0});
	while (i < p->end)
	{
		if (process_character(&data, ctx) == -1)
			return ;
	}
	finalize_expansion(&data);
}


#include "./../../include/minishell.h"

void init_exp(t_exp *exp)
{
    ft_printf("DEBUG: Entering init_exp\n");

    if (exp->result)
    {
        ft_printf("DEBUG: Freeing existing exp->result\n");
        free(exp->result);
        exp->result = NULL;
    }
    if (exp->expmap_result)
    {
        ft_printf("DEBUG: Freeing existing exp->expmap_result\n");
        free(exp->expmap_result);
        exp->expmap_result = NULL;
    }

    ft_printf("DEBUG: Allocating memory for exp->result\n");
    exp->result = ft_calloc(1, sizeof(char));
    ft_printf("DEBUG: Allocating memory for exp->expmap_result\n");
    exp->expmap_result = ft_calloc(1, sizeof(char));

    if (!exp->result || !exp->expmap_result)
    {
        ft_printf("DEBUG: Memory allocation failed in init_exp\n");
    }
    else
    {
        ft_printf("DEBUG: Memory allocation successful in init_exp\n");
    }

    ft_printf("DEBUG: Exiting init_exp\n");
}

void	handle_unexpanded_part(t_exp *exp)
{
	char	*temp;
	size_t	result_len;
	size_t	part_len;

	result_len = ft_strlen(exp->result);
	part_len = exp->end - exp->start;
	temp = ft_calloc(result_len + part_len + 1, sizeof(char));
	if (!temp)
		return ;
	ft_strlcpy(temp, exp->result, result_len + 1);
	free(exp->result);
	exp->result = temp;
	ft_strncat(exp->result, &exp->str[exp->start], part_len);
}

void	init_exp_data(t_exp_data *data)
{
	data->expanded = NULL;
	data->expanded_map = NULL;
	data->temp = NULL;
	data->expmap_temp = NULL;
}

void	setup_expand_params(t_exp *exp, t_exp_p *params, t_exp_data *data)
{
	params->m = exp->m;
	params->expanded = &data->expanded;
	params->expanded_map = &data->expanded_map;
	params->str = &exp->str[exp->start];
	params->expmap = &exp->expmap[exp->start];
	params->start = 0;
	params->end = exp->end - exp->start;
}

int	allocate_temp_memory(t_exp *e, t_exp_data *d)
{
	size_t	len;

	len = ft_strlen(e->result) + ft_strlen(d->expanded) + 1;
	d->temp = ft_calloc(len, sizeof(char));
	if (!d->temp)
		return (-1);
	return (0);
}


#include "./../../include/minishell.h"

int	allocate_expmap_temp_memory(t_exp *exp, t_exp_data *data)
{
	size_t	len;

	len = ft_strlen(exp->expmap_result) + ft_strlen(data->expanded_map) + 1;
	data->expmap_temp = ft_calloc(len, sizeof(char));
	if (!data->expmap_temp)
		return (-1);
	return (0);
}

void	update_result(t_exp *exp, t_exp_data *data)
{
	ft_strlcpy(data->temp, exp->result, ft_strlen(exp->result) + 1);
	free(exp->result);
	exp->result = data->temp;
	ft_strcat(exp->result, data->expanded);
}

void	update_expmap_result(t_exp *exp, t_exp_data *data)
{
	size_t	len;

	len = ft_strlen(exp->expmap_result) + 1;
	ft_strlcpy(data->expmap_temp, exp->expmap_result, len);
	free(exp->expmap_result);
	exp->expmap_result = data->expmap_temp;
	ft_strcat(exp->expmap_result, data->expanded_map);
}

void	cleanup_expansion_data(t_exp_data *data)
{
	free(data->expanded);
	free(data->expanded_map);
}

void	handle_expanded_part(t_exp *exp)
{
	t_exp_data		data;
	t_exp_p			params;
	t_expand_ctx	*ctx;

	ctx = NULL;
	init_exp_data(&data);
	setup_expand_params(exp, &params, &data);
	expand(&params, ctx);
	if (data.expanded && data.expanded_map)
	{
		if (allocate_temp_memory(exp, &data) == -1)
		{
			cleanup_expansion_data(&data);
			return ;
		}
		update_result(exp, &data);
		if (allocate_expmap_temp_memory(exp, &data) == -1)
		{
			free(data.temp);
			cleanup_expansion_data(&data);
			return ;
		}
		update_expmap_result(exp, &data);
	}
	cleanup_expansion_data(&data);
}


#include "./../../include/minishell.h"

void process_token(t_exp *e)
{
    ft_printf("DEBUG: Entering process_token\n");
    ft_printf("DEBUG: Token str: %s\n", e->token->str);
    ft_printf("DEBUG: Token expmap: %s\n", e->token->expmap);

    size_t i;
    char c;

    i = 0;
    while (i < ft_strlen(e->token->str))
    {
        ft_printf("DEBUG: Processing character at index %zu: %c\n", i, e->token->str[i]);
        if (e->token->expmap[i] == '1')
        {
            ft_printf("DEBUG: Handling unexpanded part\n");
            e->start = i;
            while (i < ft_strlen(e->token->str) && e->token->expmap[i] == '1')
                i++;
            e->end = i;
            handle_unexpanded_part(e);
        }
        else
        {
            ft_printf("DEBUG: Handling expanded part\n");
            e->start = i;
            c = e->token->expmap[i];
            while (i < ft_strlen(e->token->str) && e->token->expmap[i] == c)
                i++;
            e->end = i;
            handle_expanded_part(e);
        }
        ft_printf("DEBUG: After processing, i = %zu\n", i);
    }
    ft_printf("DEBUG: Exiting process_token\n");
}
void expand_token(t_minishell *m, t_token *token)
{
    ft_printf("DEBUG: Entering expand_token for token: %s\n", token->str);
    ft_printf("DEBUG: Token expmap: %s\n", token->expmap);

    t_exp exp;

    ft_printf("DEBUG: Initializing exp structure\n");
    exp.result = NULL;
    exp.expmap_result = NULL;
    exp.m = m;
    exp.token = token;
    exp.str = token->str;
    exp.expmap = token->expmap;

    ft_printf("DEBUG: Before init_exp\n");
    init_exp(&exp);
    ft_printf("DEBUG: After init_exp\n");

    if (!exp.result || !exp.expmap_result) {
        ft_printf("DEBUG: exp.result or exp.expmap_result is NULL, returning\n");
        free(exp.result);
        free(exp.expmap_result);
        return;
    }

    ft_printf("DEBUG: Before process_token\n");
    process_token(&exp);
    ft_printf("DEBUG: After process_token\n");

    ft_printf("DEBUG: Before freeing and reassigning token members\n");
    free(token->str);
    free(token->expmap);

    token->str = exp.result;
    token->expmap = exp.expmap_result;

    ft_printf("DEBUG: Exiting expand_token. New token str: %s\n", token->str);
}

int	expmapcheck(char *expmap, const char *str, int i, int escaped)
{
	if (expmap[i + 1] != '\0' && str[i + 1] != '\0' && !escaped)
	{
		if (expmap[i] == '0'
			&& expmap[i + 1] == '2'
			&& str[i + 1] == '\"')
			return (2);
		if (expmap[i + 2] != '\0'
			&& str[i + 2] != '\0'
			&& expmap[i + 1] == '0'
			&& expmap[i + 2] == '2'
			&& str[i + 1] == '\"')
			return (2);
		else if ((expmap[i] == '0' || expmap[i] == '2')
			&& expmap[i] == expmap[i + 1])
			return (1);
	}
	return (0);
}

void	expcn(char **res, char **exp_res, char **var_name, char **exit_stats)
{
	if (res && *res)
	{
		free(*res);
		*res = NULL;
	}
	if (exp_res && *exp_res)
	{
		free(*exp_res);
		*exp_res = NULL;
	}
	if (var_name && *var_name)
	{
		free(*var_name);
		*var_name = NULL;
	}
	if (exit_stats && *exit_stats)
	{
		free(*exit_stats);
		*exit_stats = NULL;
	}
}

int	initialize_expansion(t_expand_data *d)
{
	*(d->res) = ft_calloc(1, sizeof(char));
	*(d->exp_res) = ft_calloc(1, sizeof(char));
	if (!*(d->res) || !*(d->exp_res))
	{
		expcn(d->res, d->exp_res,
			d->params->expanded, d->params->expanded_map);
		return (-1);
	}
	return (0);
}


#include "./../../include/minishell.h"

int	handle_dollar_sign(t_expand_data *data, t_expand_ctx *ctx)
{
	int	ret;
	int	check;

	check = expmapcheck(data->expmap, data->str, *(data->i), *(data->escaped));
	if (data->str[*(data->i) + 1] == '?' && check == 1)
	{
		ret = handle_exit_status(data->params->m, data->res, data->exp_res);
		if (ret == -1)
			return (-1);
		*(data->i) += ret;
	}
	else if (check == 2)
		*(data->i) += 2;
	else if (check == 1)
	{
		ctx->var_start = *(data->i);
		ret = handle_variable(ctx);
		if (ret == -1)
			return (-1);
	}
	return (0);
}

int	handle_escape_character(t_expand_data *d)
{
	int	ret;

	ret = handle_escape(d->res, d->exp_res, d->escaped);
	if (ret == -1)
	{
		expcn(d->res, d->exp_res, d->params->expanded, d->params->expanded_map);
		return (-1);
	}
	if (ret > 0)
	{
		*(d->i) += ret;
	}
	return (0);
}

int	append_regular_character(t_expand_data *data)
{
	char	*temp;
	char	*exp_tmp;

	temp = ft_calloc(ft_strlen(*(data->res)) + 2, sizeof(char));
	exp_tmp = ft_calloc(ft_strlen(*(data->exp_res)) + 2, sizeof(char));
	if (!temp || !exp_tmp)
	{
		expcn(data->res, data->exp_res, NULL, NULL);
		return (-1);
	}
	ft_strlcpy(temp, *(data->res), ft_strlen(*(data->res)) + 1);
	ft_strlcpy(exp_tmp, *(data->exp_res), ft_strlen(*(data->exp_res)) + 1);
	free(*(data->res));
	free(*(data->exp_res));
	*(data->res) = temp;
	*(data->exp_res) = exp_tmp;
	ft_strncat(*(data->res), &(data->str[*(data->i)]), 1);
	ft_strncat(*(data->exp_res), &(data->expmap[*(data->i)]), 1);
	return (0);
}

int process_character(t_expand_data *data, t_expand_ctx *ctx)
{
    int ret;

    ft_printf("DEBUG: Before processing character at index %zu\n", *(data->i));
    ft_printf("Current data->res: %p (%s)\n", *(data->res), *(data->res));
    ft_printf("Current data->exp_res: %p (%s)\n", *(data->exp_res), *(data->exp_res));

    if (data->expmap[*(data->i)] == 'S') {
        (*(data->i))++;
        return (0);
    }

    if (data->str[*(data->i)] == '\\') {
        return (handle_escape_character(data));
    }

    ret = expmapcheck(data->expmap, data->str, *(data->i), *(data->escaped));
    if (data->str[*(data->i)] == '$' && ret != 0) {
        return (handle_dollar_sign(data, ctx));
    }

    if (data->str[*(data->i)] != '"') {
        ret = append_regular_character(data);
        if (ret == 0) {
            (*(data->i))++;
        }
        return (ret);
    }

    (*(data->i))++;

    ft_printf("DEBUG: After processing character at index %zu\n", *(data->i));
    ft_printf("Updated data->res: %p (%s)\n", *(data->res), *(data->res));
    ft_printf("Updated data->exp_res: %p (%s)\n", *(data->exp_res), *(data->exp_res));

    return (0);
}

void finalize_expansion(t_expand_data *data)
{
    ft_printf("DEBUG: Finalizing expansion\n");
    ft_printf("Final res: %p (%s)\n", *(data->res), *(data->res));
    ft_printf("Final exp_res: %p (%s)\n", *(data->exp_res), *(data->exp_res));

    *(data->params->expanded) = *(data->res);
    *(data->params->expanded_map) = *(data->exp_res);
}


#include "./../../include/minishell.h"

void	ft_strfillcat(char *dest, const char *src, char fill_char)
{
	char	*dest_end;
	size_t	src_len;
	size_t	i;

	dest_end = dest + ft_strlen(dest);
	src_len = ft_strlen(src);
	i = 0;
	while (i < src_len)
	{
		dest_end[i] = fill_char;
		i++;
	}
	dest_end[src_len] = '\0';
}

char	*get_var_name_exp(const char *str, const char *expmap, size_t *pos)
{
	size_t	start;
	size_t	end;
	char	*var_name;

	start = *pos + 1;
	end = start;
	while (str[end] && ft_strchr(VS, str[end])
		&& (expmap[end] == expmap[start]))
		end++;
	if (end == start)
		return (NULL);
	var_name = malloc(end - start + 1);
	if (!var_name)
		return (NULL);
	ft_strncpy(var_name, &str[start], end - start);
	var_name[end - start] = '\0';
	*pos = end;
	return (var_name);
}

char	*get_var_name(const char *str, size_t *pos)
{
	size_t	start;
	size_t	end;
	char	*var_name;

	start = *pos + 1;
	end = start;
	while (str[end] && ft_strchr(VS, str[end]))
		end++;
	if (end == start)
		return (NULL);
	var_name = malloc(end - start + 1);
	if (!var_name)
		return (NULL);
	ft_strncpy(var_name, &str[start], end - start);
	var_name[end - start] = '\0';
	*pos = end;
	return (var_name);
}


#include "./../../include/minishell.h"

static int	append_str(char **dst, const char *src)
{
	char	*temp;
	size_t	dst_len;
	size_t	src_len;

	if (!dst || !*dst || !src)
		return (0);
	dst_len = ft_strlen(*dst);
	src_len = ft_strlen(src);
	temp = ft_calloc(dst_len + src_len + 1, sizeof(char));
	if (!temp)
		return (0);
	ft_strlcpy(temp, *dst, dst_len + 1);
	ft_strlcat(temp, src, dst_len + src_len + 1);
	free(*dst);
	*dst = temp;
	return (1);
}

static int	append_char(char **dst, char c)
{
	char	*temp;
	size_t	len;

	if (!dst || !*dst)
		return (0);
	len = ft_strlen(*dst);
	temp = ft_calloc(len + 2, sizeof(char));
	if (!temp)
		return (0);
	ft_strlcpy(temp, *dst, len + 1);
	temp[len] = c;
	free(*dst);
	*dst = temp;
	return (1);
}

static char	*expand_exit_status(t_minishell *m, char **result)
{
	char	*exit_status_str;

	exit_status_str = ft_itoa(m->last_exitcode);
	if (!exit_status_str || !append_str(result, exit_status_str))
	{
		free(exit_status_str);
		free(*result);
		return (NULL);
	}
	free(exit_status_str);
	return (*result);
}

char	*expand_var(t_minishell *m, char *str, size_t *i, char **result)
{
	char	*var_name;
	char	*var_value;

	var_name = get_var_name(str, i);
	if (var_name)
	{
		var_value = my_getenv(var_name, m->env_list);
		if (var_value && !append_str(result, var_value))
		{
			free(var_name);
			free(*result);
			return (NULL);
		}
		free(var_name);
	}
	else if (!append_char(result, '$'))
	{
		free(*result);
		return (NULL);
	}
	return (*result);
}

char *expand_hd(t_minishell *m, char *str)
{
    char *result;
    size_t i;

    i = 0;
    result = ft_strdup("");
    if (!result)
        return NULL;
    while (str[i]) {
        if (str[i] == '$' && str[i + 1] == '?') {
            if (!expand_exit_status(m, &result)) {
                free(result);  // Fügen Sie diese Zeile hinzu
                return NULL;
            }
            i++;
        } else if (str[i] == '$' && !expand_var(m, str, &i, &result)) {
            free(result);  // Fügen Sie diese Zeile hinzu
            return NULL;
        } else if (str[i] != '"' && !append_char(&result, str[i])) {
            free(result);  // Fügen Sie diese Zeile hinzu
            return NULL;
        }
        i++;
    }
    return result;
}


#include "./../../include/minishell.h"


#include "./../../include/minishell.h"

int	are_inputs_valid(char **result, char **expmap_result, int *escaped)
{
	return (result && expmap_result && escaped && *result && *expmap_result);
}

int	handle_first_esc(int *escaped)
{
	*escaped = 1;
	return (1);
}

int	handle_second_esc(char **result, char **expmap_result, int *escaped)
{
	char	*temp;
	char	*expmap_temp;

	*escaped = 0;
	if (!allocate_new_buf(&temp, &expmap_temp, *result, *expmap_result))
	{
		expcn(result, expmap_result, NULL, NULL);
		return (-1);
	}
	append_esc_character(temp, expmap_temp, *result, *expmap_result);
	free(*result);
	free(*expmap_result);
	*result = temp;
	*expmap_result = expmap_temp;
	return (1);
}


#include "./../../include/minishell.h"

int	allocate_new_buf(char **t, char **et, const char *r, const char *er)
{
	size_t	result_len;
	size_t	expmap_len;

	result_len = ft_strlen(r);
	expmap_len = ft_strlen(er);
	*t = ft_calloc(result_len + 2, sizeof(char));
	*et = ft_calloc(expmap_len + 2, sizeof(char));
	if (!*t || !*et)
	{
		free(*t);
		free(*et);
		return (0);
	}
	return (1);
}

void	append_esc_character(char *t, char *e, const char *r, const char *er)
{
	size_t	result_len;
	size_t	expmap_len;

	result_len = ft_strlen(r);
	expmap_len = ft_strlen(er);
	ft_strlcpy(t, r, result_len + 1);
	ft_strlcpy(e, er, expmap_len + 1);
	t[result_len] = '\\';
	e[expmap_len] = '0';
}

int	handle_escape(char **result, char **expmap_result, int *escaped)
{
	if (!are_inputs_valid(result, expmap_result, escaped))
		return (-1);
	if (*escaped == 0)
		return (handle_first_esc(escaped));
	else if (*escaped == 1)
		return (handle_second_esc(result, expmap_result, escaped));
	return (0);
}


#include "./../../include/minishell.h"

int	are_exitinputs_valid(t_minishell *m, char **res, char **expmap_res)
{
	return (m && res && expmap_res && *res && *expmap_res);
}

char	*get_exit_status_str(t_minishell *m)
{
	return (ft_itoa(m->last_exitcode));
}


#include "./../../include/minishell.h"

int	alloc_exit_buf(char **temp, char **temp2, size_t res_len, size_t exit_len)
{
	*temp = ft_calloc(res_len + exit_len + 1, sizeof(char));
	*temp2 = ft_calloc(res_len + exit_len + 1, sizeof(char));
	if (!*temp || !*temp2)
	{
		free(*temp);
		return (0);
	}
	return (1);
}

void	add_str(char *dst, const char *src1, const char *src2, size_t len_total)
{
	size_t	len1;

	len1 = ft_strlen(src1);
	ft_strlcpy(dst, src1, len1 + 1);
	ft_strlcat(dst, src2, len_total + 1);
}

int	add_expmap(char *dst, const char *src, const char *exit_str, char def_char)
{
	size_t	res_len;
	char	fill_char;

	res_len = ft_strlen(src);
	ft_strlcpy(dst, src, res_len + 1);
	if (res_len > 0)
		fill_char = src[res_len - 1];
	else
		fill_char = def_char;
	ft_strfillcat(dst, exit_str, fill_char);
	return (0);
}

int	add_exit_status(char **res, char **expmap_res, const char *exit)
{
	t_temps	t;
	size_t	res_len;
	size_t	exit_len;

	res_len = ft_strlen(*res);
	exit_len = ft_strlen(exit);
	if (!alloc_exit_buf(&t.temp, &t.expmap, res_len, exit_len))
	{
		expcn(res, expmap_res, NULL, NULL);
		return (0);
	}
	add_str(t.temp, *res, exit, exit_len);
	add_expmap(t.expmap, *expmap_res, exit, res_len);
	free(*res);
	free(*expmap_res);
	*res = t.temp;
	*expmap_res = t.expmap;
	return (1);
}

int	handle_exit_status(t_minishell *m, char **res, char **expmap_res)
{
	char	*exit_status_str;

	if (!are_exitinputs_valid(m, res, expmap_res))
		return (-1);
	exit_status_str = get_exit_status_str(m);
	if (!exit_status_str)
	{
		expcn(res, expmap_res, NULL, NULL);
		return (-1);
	}
	if (!add_exit_status(res, expmap_res, exit_status_str))
	{
		free(exit_status_str);
		return (-1);
	}
	free(exit_status_str);
	return (2);
}


#include "./../../include/minishell.h"

char	*read_heredoc_line(void)
{
	char	*line;
	// checke ob pipes da sind mach if else ande esignal function
	signal(SIGINT, handle_heredoc_signal);
	line = readline("📄 ");
	signal(SIGINT, handle_main_process);
	return (line);
}

int	append_line_to_heredoc(char **heredoc_content, const char *line)
{
	char	*temp;

	temp = ft_strjoin(*heredoc_content, line);
	if (!temp)
		return (0);
	free(*heredoc_content);
	*heredoc_content = temp;
	temp = ft_strjoin(*heredoc_content, "\n");
	if (!temp)
		return (0);
	free(*heredoc_content);
	*heredoc_content = temp;
	return (1);
}

char	*read_heredoc_content(const char *delimiter)
{
	char	*heredoc_content;
	char	*line;

	heredoc_content = ft_strdup("");
	if (!heredoc_content)
		return (NULL);
	while (1)
	{
		line = read_heredoc_line();
		if (!line || ft_strcmp(line, delimiter) == 0)
		{
			free(line);
			break ;
		}
		if (!append_line_to_heredoc(&heredoc_content, line))
		{
			free(line);
			free(heredoc_content);
			return (NULL);
		}
		free(line);
	}
	return (heredoc_content);
}

char	*expand_heredoc_content(t_minishell *m, char *heredoc_content)
{
	char	*expanded;

	expanded = expand_hd(m, heredoc_content);
	if (expanded)
	{
		free(heredoc_content);
		return (expanded);
	}
	return (heredoc_content);
}

void	handle_heredoc(t_minishell *m, t_list *current)
{
	t_token	*token;
	t_token	*next_content;
	char	*heredoc_content;
	char	*delimiter;

	token = (t_token *)current->content;
	next_content = get_next_content(current);
	if (next_content)
		delimiter = next_content->str;
	else
		delimiter = "";
	heredoc_content = read_heredoc_content(delimiter);
	if (!heredoc_content)
		return ;
	if (next_content && !next_content->had_quote)
		heredoc_content = expand_heredoc_content(m, heredoc_content);
	token->rdrcmeta = heredoc_content;
}


#include "./../../include/minishell.h"

void	handle_infile(t_list *current)
{
	t_token	*next_content;
	char	*filename;
	t_token	*token;

	token = (t_token *)current->content;
	next_content = NULL;
	if (current->next)
		next_content = (t_token *)current->next->content;
	filename = next_content->str;
	if (access(filename, R_OK) == -1)
	{
		ft_fprintf(2, "Error: Cannot access file '%s'\n", filename);
		return ;
	}
	token->rdrcmeta = ft_strdup(filename);
	token->rdrctarget = filename;
}


#include "./../../include/minishell.h"

t_token	*get_next_content(t_list *current)
{
	if (current->next)
		return ((t_token *)current->next->content);
	return (NULL);
}

void	handle_allocation_error(char *filecontent, char *line)
{
	ft_fprintf(2, "Error: Memory allocation failed\n");
	free(filecontent);
	free(line);
}

char	*add_line(char *cont, char *tmp, const char *line, size_t total_size)
{
	if (cont)
	{
		ft_strlcpy(tmp, cont, total_size + 1);
		free(cont);
	}
	ft_strlcpy(tmp + total_size, line, ft_strlen(line) + 1);
	return (tmp);
}


#include "./../../include/minishell.h"

char	*read_file_content(int fd)
{
	t_temps	t;
	size_t	total_size;
	size_t	line_len;

	t.filecontent = NULL;
	total_size = 0;
	while (1)
	{
		t.line = get_next_line(fd);
		if (t.line == NULL)
			break ;
		line_len = ft_strlen(t.line);
		t.temp = ft_calloc(total_size + line_len + 1, sizeof(char));
		if (!t.temp)
			return (handle_allocation_error(t.filecontent, t.line), NULL);
		t.filecontent = add_line(t.filecontent, t.temp, t.line, total_size);
		total_size += line_len;
		free(t.line);
	}
	if (t.filecontent)
		return (t.filecontent);
	else
		return (ft_strdup(""));
}

char	*read_existing_file(const char *filename)
{
	int		fd;
	char	*filecontent;

	fd = open(filename, O_RDONLY);
	if (fd == -1)
		return (ft_strdup(""));
	filecontent = read_file_content(fd);
	close(fd);
	return (filecontent);
}

char	*create_new_file(const char *filename)
{
	int		fd;
	char	*filecontent;

	filecontent = ft_strdup("");
	fd = open(filename, O_WRONLY | O_CREAT, 0644);
	if (fd == -1)
	{
		ft_fprintf(2, "Error: Cannot create file '%s'\n", filename);
		free(filecontent);
		return (NULL);
	}
	close(fd);
	return (filecontent);
}

void	handle_trunc_append(t_list *current)
{
	t_token	*token;
	t_token	*next_content;
	char	*filename;
	char	*filecontent;

	token = (t_token *)current->content;
	next_content = get_next_content(current);
	filename = next_content->str;
	if (access(filename, F_OK) != -1)
		filecontent = read_existing_file(filename);
	else
		filecontent = create_new_file(filename);
	if (!filecontent)
		return ;
	token->rdrcmeta = filecontent;
	token->rdrctarget = filename;
}


#include "./../../include/minishell.h"

int	handle_no_var_name(t_expand_ctx *ctx)
{
	char	*temp;
	char	*expmap_temp;
	size_t	result_len;

	result_len = ft_strlen(*(ctx->result));
	temp = ft_calloc(result_len + 2, sizeof(char));
	expmap_temp = ft_calloc(result_len + 2, sizeof(char));
	if (!temp || !expmap_temp)
	{
		free(temp);
		free(expmap_temp);
		expcn(ctx->result, ctx->expmap_result, NULL, NULL);
		return (-1);
	}
	ft_strlcpy(temp, *(ctx->result), result_len + 1);
	ft_strlcpy(expmap_temp, *(ctx->expmap_result), result_len + 1);
	temp[result_len] = ctx->str[ctx->var_start];
	expmap_temp[result_len] = ctx->expmap[ctx->var_start];
	free(*(ctx->result));
	free(*(ctx->expmap_result));
	*(ctx->result) = temp;
	*(ctx->expmap_result) = expmap_temp;
	*(ctx->i) = ctx->var_start + 1;
	return (0);
}

int	allocate_memory(t_memory_info *m)
{
	m->temp = ft_calloc(m->result_len + m->value_len + 1, sizeof(char));
	m->expmap_temp = ft_calloc(m->expmap_len + m->value_len + 1, sizeof(char));
	if (!m->temp || !m->expmap_temp)
	{
		free(m->temp);
		free(m->expmap_temp);
		return (-1);
	}
	return (0);
}


#include "./../../include/minishell.h"

void	copy_and_concatenate(t_expand_ctx *ctx, t_memory_info *m, char *v)
{
	ft_strlcpy(m->temp, *(ctx->result), m->result_len + 1);
	ft_strlcat(m->temp, v, m->result_len + m->value_len + 1);
	ft_strlcpy(m->expmap_temp, *(ctx->expmap_result), m->expmap_len + 1);
}

void	update_expmap(t_expand_ctx *ctx, char *expmap_temp, char *var_value)
{
	if (ft_strcontains(ctx->expmap, '2'))
	{
		ft_strfillcat(expmap_temp, var_value, 'X');
	}
	else
	{
		ft_strfillcat(expmap_temp, var_value, 'E');
	}
}

void	update_and_free(t_expand_ctx *ctx, t_memory_info *mem_info)
{
	free(*(ctx->result));
	free(*(ctx->expmap_result));
	*(ctx->result) = mem_info->temp;
	*(ctx->expmap_result) = mem_info->expmap_temp;
}

int	handle_var_value(t_expand_ctx *ctx, char *var_value)
{
	t_memory_info	mem_info;

	mem_info.result_len = ft_strlen(*(ctx->result));
	mem_info.expmap_len = ft_strlen(*(ctx->expmap_result));
	mem_info.value_len = ft_strlen(var_value);
	if (allocate_memory(&mem_info) == -1)
	{
		expcn(ctx->result, ctx->expmap_result, NULL, NULL);
		return (-1);
	}
	copy_and_concatenate(ctx, &mem_info, var_value);
	update_expmap(ctx, mem_info.expmap_temp, var_value);
	update_and_free(ctx, &mem_info);
	return (0);
}

int	handle_variable(t_expand_ctx *ctx)
{
	char	*var_name;
	char	*var_value;

	var_name = get_var_name_exp(ctx->str, ctx->expmap, ctx->i);
	if (!var_name)
	{
		return (handle_no_var_name(ctx));
	}
	var_value = my_getenv(var_name, ctx->m->env_list);
	if (var_value)
	{
		if (handle_var_value(ctx, var_value) == -1)
		{
			free(var_name);
			return (-1);
		}
	}
	free(var_name);
	return (0);
}


#include "./../../include/minishell.h"

void	reduce_internal_whitespace(const char *str, char *new_str)
{
	int	i;
	int	j;
	int	in_whitespace;

	i = 0;
	j = 0;
	in_whitespace = 0;
	while (str[i] != '\0')
	{
		if (isspace(str[i]))
		{
			if (!in_whitespace)
			{
				new_str[j++] = ' ';
				in_whitespace = 1;
			}
		}
		else
		{
			new_str[j++] = str[i];
			in_whitespace = 0;
		}
		i++;
	}
	new_str[j] = '\0';
}

char	*handle_whitespaces(const char *str)
{
	char	*new_str;
	int		new_str_len;

	new_str_len = strlen(str) + 1;
	new_str = malloc(new_str_len);
	if (new_str == NULL)
	{
		return (NULL);
	}
	reduce_internal_whitespace(str, new_str);
	return (new_str);
}


#include "./../include/minishell.h"

void    increment_shlvl(char **value)
{
    int     i;
    int     carry;
    char    *new_value;
    i = strlen(*value) - 1;
    carry = 1;
    while (i >= 0 && carry)
    {
        if ((*value)[i] < '9')
        {
            (*value)[i] += 1;
            carry = 0;
        }
        else
        {
            (*value)[i] = '0';
        }
        i--;
    }
    if (carry)
    {
        new_value = malloc(strlen(*value) + 2);
        new_value[0] = '1';
        strcpy(new_value + 1, *value);
        free(*value);
        *value = new_value;
    }
}
void    init_env_list(char **envp, t_minishell *m)
{
    char    *name;
    char    *value;
    while (*envp != NULL)
    {
        name = NULL;
        value = NULL;
        extract_name_value(*envp, &name, &value);
        if (ft_strcmp(name, "SHLVL") == 0)
            increment_shlvl(&value);
        if (ft_strcmp(name, "OLDPWD") != 0)
            add_env_node(&m->env_list, name, value);
        else
            ft_multifree(name, value, NULL, NULL);
        envp++;
    }
    add_env_node(&m->env_list, ft_strdup("OLDPWD"), NULL);
}
void    extract_name_value(char *arg, char **name, char **value)
{
    char    *equal_sign;
    char    *plus_sign;
    char    *trimmed_value;
    plus_sign = ft_strchr(arg, '+');
    equal_sign = ft_strchr(arg, '=');
    if (equal_sign)
    {
        if (plus_sign && plus_sign < equal_sign)
            *name = ft_strndup(arg, plus_sign - arg);
        else
            *name = ft_strndup(arg, equal_sign - arg);
        trimmed_value = ft_strtrim(equal_sign + 1, "\"");
        *value = ft_strdup(trimmed_value);
        free(trimmed_value);
    }
    else
    {
        *name = ft_strdup(arg);
        *value = NULL;
        free(arg);
    }
}
void    add_env_node(t_envlst **env_list, char *name, char *value)
{
    t_envlst    *new_node;
    t_envlst    *temp;
    new_node = malloc(sizeof(t_envlst));
    if (new_node == NULL)
    {
        free(name);
        free(value);
        return ((void)ft_printf(MEM_ERR));
    }
    new_node->name = name;
    new_node->value = value;
    new_node->next = NULL;
    if (*env_list == NULL)
        *env_list = new_node;
    else
    {
        temp = *env_list;
        while (temp->next != NULL)
            temp = temp->next;
        temp->next = new_node;
    }
}
t_envlst    *find_env_var(t_envlst *head, const char *name)
{
    t_envlst    *current;
    current = head;
    while (current != NULL)
    {
        if (ft_strcmp(current->name, name) == 0)
            return (current);
        current = current->next;
    }
    return (NULL);
}

#include "./../../include/minishell.h"

void    add_token_to_list(t_list **lst, t_token *token)
{
    ft_lstadd_back(lst, ft_lstnew(token));
}

// void	prompt_to_token(char *prompt, t_list **tok_lst)
// {
// 	int		current_pos;
// 	int		quote_level;
// 	int		escape_next;
// 	int		current_token_size;
// 	t_token	*token;
// 	char	*ptr;
// 	char	*current_token;
// 	char	*expmap;
// 	char	*new_token;
// 	char	*new_expmap;
// 	int		new_size;

// 	current_pos = 0;
// 	quote_level = 0;
// 	escape_next = 0;
// 	current_token_size = 10;
// 	ptr = prompt;
// 	current_token = ft_calloc(current_token_size, sizeof(char));
// 	expmap = ft_calloc(current_token_size, sizeof(char));
// 	if (!current_token || !expmap)
// 	{
// 		free(current_token);
// 		free(expmap);
// 		ft_error_exit("malloc");
// 	}
// 	while (*ptr)
// 	{
// 		if (escape_next)
// 		{
// 			current_token[current_pos] = *ptr;
// 			if (quote_level == 2)
// 				expmap[current_pos] = '2';
// 			else
// 				expmap[current_pos] = '0';
// 			current_pos++;
// 			escape_next = 0;
// 			ptr++;
// 			continue ;
// 		}
// 		if (*ptr == '\\' && !escape_next)
// 		{
// 			escape_next = 1;
// 			current_token[current_pos] = *ptr;
// 			expmap[current_pos] = '0';
// 			current_pos++;
// 			ptr++;
// 			continue ;
// 		}
// 		if (*ptr == '\'' && quote_level == 0)
// 		{
// 			quote_level = 1;
// 			current_token[current_pos] = *ptr;
// 			expmap[current_pos] = 'S';
// 			current_pos++;
// 			ptr++;
// 			continue ;
// 		}
// 		if (*ptr == '\'' && quote_level == 1)
// 		{
// 			quote_level = 0;
// 			current_token[current_pos] = *ptr;
// 			expmap[current_pos] = 'S';
// 			current_pos++;
// 			ptr++;
// 			continue ;
// 		}
// 		if (*ptr == '"' && quote_level != 1)
// 		{
// 			current_token[current_pos] = *ptr;
// 			expmap[current_pos] = '0';
// 			current_pos++;
// 			if (quote_level == 2)
// 				quote_level = 0;
// 			else
// 				quote_level = 2;
// 			ptr++;
// 			continue ;
// 		}
// 		if (ft_isspace(*ptr) && quote_level == 0 && !escape_next)
// 		{
// 			if (current_pos > 0)
// 			{
// 				current_token[current_pos] = '\0';
// 				expmap[current_pos] = '\0';
// 				token = create_token(current_token, expmap);
// 				update_tok_type(token, WORD);
// 				add_token_to_list(tok_lst, token);
// 				current_pos = 0;
// 			}
// 			ptr++;
// 			continue ;
// 		}
// 		if (*ptr == '|' && quote_level == 0)
// 		{
// 			if (current_pos > 0)
// 			{
// 				current_token[current_pos] = '\0';
// 				expmap[current_pos] = '\0';
// 				token = create_token(current_token, expmap);
// 				update_tok_type(token, WORD);
// 				add_token_to_list(tok_lst, token);
// 				current_pos = 0;
// 			}
// 			token = create_token("|", "0");
// 			update_tok_type(token, PIPE);
// 			add_token_to_list(tok_lst, token);
// 			ptr++;
// 			continue ;
// 		}
// 		if ((*ptr == '>' || *ptr == '<') && quote_level == 0)
// 		{
// 			if (current_pos > 0)
// 			{
// 				current_token[current_pos] = '\0';
// 				expmap[current_pos] = '\0';
// 				token = create_token(current_token, expmap);
// 				update_tok_type(token, WORD);
// 				add_token_to_list(tok_lst, token);
// 				current_pos = 0;
// 			}
// 			if (*(ptr + 1) == *ptr)
// 			{
// 				if (*ptr == '>')
// 					token = create_token(">>", "00");
// 				else
// 					token = create_token("<<", "00");
// 				ptr++;
// 			}
// 			else
// 			{
// 				if (*ptr == '>')
// 					token = create_token(">", "0");
// 				else
// 					token = create_token("<", "0");
// 			}
// 			update_tok_type(token, REDIRECTION);
// 			add_token_to_list(tok_lst, token);
// 			ptr++;
// 			continue ;
// 		}
// 		current_token[current_pos] = *ptr;
// 		if (quote_level == 1)
// 			expmap[current_pos] = '1';
// 		else if (quote_level == 2)
// 			expmap[current_pos] = '2';
// 		else
// 			expmap[current_pos] = '0';
// 		current_pos++;
// 		if (current_pos >= current_token_size - 1)
// 		{
// 			new_size = current_token_size * 2;
// 			new_token = ft_calloc(new_size, sizeof(char));
// 			new_expmap = ft_calloc(new_size, sizeof(char));
// 			if (!new_token || !new_expmap)
// 			{
// 				free(current_token);
// 				free(expmap);
// 				if (new_token)
// 					free(new_token);
// 				if (new_expmap)
// 					free(new_expmap);
// 				ft_error_exit("calloc");
// 			}
// 			ft_memcpy(new_token, current_token, current_token_size);
// 			ft_memcpy(new_expmap, expmap, current_token_size);
// 			free(current_token);
// 			free(expmap);
// 			current_token = new_token;
// 			expmap = new_expmap;
// 			current_token_size = new_size;
// 		}
// 		ptr++;
// 	}
// 	if (current_pos > 0)
// 	{
// 		current_token[current_pos] = '\0';
// 		expmap[current_pos] = '\0';
// 		token = create_token(current_token, expmap);
// 		update_tok_type(token, WORD);
// 		add_token_to_list(tok_lst, token);
// 	}
// 	free(current_token);
// 	free(expmap);
// }
//free(cur_content->expmap);
//cur_content->expmap = NULL;
//ft_printf(R"%s\n"D, cur_content->str);
//ft_printf(G"%s\n"D, cur_content->expmap);
void	expand_toklst(t_minishell *m, t_list **tok_lst)
{
	t_list	*current;
	t_token	*cur_content;

    ft_printf("DEBUG: Entering expand_toklst\n");
	current = *tok_lst;
	while (current != NULL)
	{
		cur_content = (t_token *)current->content;
        ft_printf("DEBUG: Expanding token: %s\n", cur_content->str);
		expand_token(m, cur_content);
        ft_printf("DEBUG: After expansion: %s\n", cur_content->str);
		current = current->next;
	}
    ft_printf("DEBUG: Exiting expand_toklst\n");
}


void	lex_prompt(t_minishell *m)
{
	// char	*tmpp;

	// tmpp = remove_chars(m->prompt, "\n");
	// m->prompt = tmpp;
	// if (tmpp != m->prompt)
	// {
	// 	free(m->prompt);
	// 	m->prompt = tmpp;
	// }
	detect_lexing_errors(m);
	prompt_to_token(m);
	if (DEBUG == 1)
	{
		ft_printf(Y"TOKENs:\n"D);
		ft_lstput(&(m->tok_lst), put_token, '\n');
	}
	expand_toklst(m, &(m->tok_lst));
	if (DEBUG == 1)
	{
		ft_printf(Y"TOKENLIST:\n"D);
		ft_lstput(&(m->tok_lst), put_token, '\n');
	}
	afterbreakup(&(m->tok_lst));
}


#include "./../../include/minishell.h"

void	add_new_abtoken(t_list **current, char *word, char *expmap)
{
	t_token	*new_token;
	t_list	*new_node;

	ft_printf("add_new_abtoken\n");
	new_token = create_token(word, expmap);
	update_tok_type(new_token, WORD);
	new_node = ft_lstnew(new_token);
	new_node->next = (*current)->next;
	(*current)->next = new_node;
	*current = new_node;
}

void	process_abtoken(t_list **current, t_token *cur)
{
	char	*work;
	char	**words;
	int		wordcount;
	int		i;
	t_list	*next_node;

	next_node = (*current)->next;
	work = whitespace_handler(cur->str);
	wordcount = ft_count_words(work, ' ');
	words = ft_split(work, ' ');

	// Freigeben des ursprünglichen `cur->str` Speicherbereichs
	free(cur->str);

	// Setze `cur->str` auf das erste Wort in `words`
	cur->str = words[0];

	i = 1;
	while (i < wordcount)
	{
		add_new_abtoken(current, words[i], cur->expmap);  // Füge jedes weitere Wort als neues Token hinzu
		free(words[i]);  // Freigeben der nicht mehr benötigten Strings
		i++;
	}

	free(words);  // Freigeben des Arrays `words` selbst
	*current = next_node;  // Setze den aktuellen Zeiger auf den nächsten Knoten
}

int	should_process_token(t_token *t)
{
	return (!ft_strcontains(t->expmap, 'X') && ft_strcontains(t->expmap, 'E'));
}

void	afterbreakup(t_list **tok_lst)
{
	t_list	*current;
	t_token	*cur;

	current = *tok_lst;
	while (current != NULL)
	{
		cur = (t_token *)current->content;
		if (should_process_token(cur))
		{
			process_abtoken(&current, cur);
		}
		else
		{
			current = current->next;
		}
	}
}

void	detect_lexing_errors(t_minishell *m)
{
	char	*work;
	char	quote_char;
	int		in_quote;

	work = m->prompt;
	quote_char = 0;
	in_quote = 0;
	while (*work != '\0')
	{
		if (!in_quote && (*work == '\'' || *work == '\"'))
		{
			quote_char = *work;
			in_quote = 1;
		}
		else if (in_quote && *work == quote_char)
			in_quote = 0;
		work++;
	}
	if (in_quote)
		pic_err(m, 2, "unclosed quotes");
}


#include "./../../include/minishell.h"

void	handle_double_redirection(t_minishell *m, t_tokenizer_state *state)
{
	if (*state->ptr == '>')
		create_rdrct_token(m, ">>", "00");
	else
		create_rdrct_token(m, "<<", "00");
	state->ptr++;
}

void	handle_single_redirection(t_minishell *m, t_tokenizer_state *state)
{
	if (*state->ptr == '>')
		create_rdrct_token(m, ">", "0");
	else
		create_rdrct_token(m, "<", "0");
}

void	handle_redirection(t_minishell *m, t_tokenizer_state *state)
{
	handle_current_token(m, state);
	if (*(state->ptr + 1) == *state->ptr)
		handle_double_redirection(m, state);
	else
		handle_single_redirection(m, state);
	state->ptr++;
}

void	handle_regular_char(t_tokenizer_state *state)
{
	state->current_token[state->current_pos] = *state->ptr;
	if (state->quote_level == 1)
		state->expmap[state->current_pos] = '1';
	else if (state->quote_level == 2)
		state->expmap[state->current_pos] = '2';
	else
		state->expmap[state->current_pos] = '0';
	state->current_pos++;
	state->ptr++;
}

void	resize_token_buffers(t_tokenizer_state *state)
{
	int		new_size;
	char	*new_token;
	char	*new_expmap;

	new_size = state->current_token_size * 2;
	new_token = ft_calloc(new_size, sizeof(char));
	new_expmap = ft_calloc(new_size, sizeof(char));
	if (!new_token || !new_expmap)
	{
		free(state->current_token);
		free(state->expmap);
		if (new_token)
			free(new_token);
		if (new_expmap)
			free(new_expmap);
		ft_error_exit("calloc");
	}
	ft_memcpy(new_token, state->current_token, state->current_token_size);
	ft_memcpy(new_expmap, state->expmap, state->current_token_size);
	free(state->current_token);
	free(state->expmap);
	state->current_token = new_token;
	state->expmap = new_expmap;
	state->current_token_size = new_size;
}


#include "./../../include/minishell.h"

void	handle_double_quote(t_tokenizer_state *state)
{
	state->current_token[state->current_pos] = *state->ptr;
	state->expmap[state->current_pos] = '0';
	state->current_pos++;
	if (state->quote_level == 2)
		state->quote_level = 0;
	else
		state->quote_level = 2;
	state->ptr++;
}

void	handle_space(t_minishell *m, t_tokenizer_state *state)
{
	t_token	*token;

	if (state->current_pos > 0)
	{
		state->current_token[state->current_pos] = '\0';
		state->expmap[state->current_pos] = '\0';
		token = create_token(state->current_token, state->expmap);
		update_tok_type(token, WORD);
		add_token_to_list(&(m->tok_lst), token);
		state->current_pos = 0;
	}
	state->ptr++;
}

void	handle_pipe(t_minishell *m, t_tokenizer_state *state)
{
	t_token	*token;

	if (state->current_pos > 0)
	{
		state->current_token[state->current_pos] = '\0';
		state->expmap[state->current_pos] = '\0';
		token = create_token(state->current_token, state->expmap);
		update_tok_type(token, WORD);
		add_token_to_list(&(m->tok_lst), token);
		state->current_pos = 0;
	}
	token = create_token("|", "0");
	update_tok_type(token, PIPE);
	add_token_to_list(&(m->tok_lst), token);
	state->ptr++;
}

void	handle_current_token(t_minishell *m, t_tokenizer_state *state)
{
	t_token	*token;

	if (state->current_pos > 0)
	{
		state->current_token[state->current_pos] = '\0';
		state->expmap[state->current_pos] = '\0';
		token = create_token(state->current_token, state->expmap);
		update_tok_type(token, WORD);
		add_token_to_list(&(m->tok_lst), token);
		state->current_pos = 0;
	}
}

void	create_rdrct_token(t_minishell *m, char *rdrct, char *expmap)
{
	t_token	*token;

	token = create_token(rdrct, expmap);
	update_tok_type(token, REDIRECTION);
	add_token_to_list(&(m->tok_lst), token);
}


#include "./../../include/minishell.h"

void	handle_escape_char(t_tokenizer_state *state)
{
	state->current_token[state->current_pos] = *state->ptr;
	if (state->quote_level == 2)
		state->expmap[state->current_pos] = '2';
	else
		state->expmap[state->current_pos] = '0';
	state->current_pos++;
	state->ptr++;
}

void	handle_backslash(t_tokenizer_state *state)
{
	state->escape_next = 1;
	state->current_token[state->current_pos] = *state->ptr;
	state->expmap[state->current_pos] = '0';
	state->current_pos++;
	state->ptr++;
}

void	handle_single_quote(t_tokenizer_state *state)
{
	if (state->quote_level == 0)
		state->quote_level = 1;
	else if (state->quote_level == 1)
		state->quote_level = 0;
	state->current_token[state->current_pos] = *state->ptr;
	state->expmap[state->current_pos] = 'S';
	state->current_pos++;
	state->ptr++;
}


#include "./../../include/minishell.h"

void	init_tokenizer_state(t_tokenizer_state *state, char *p)
{
	*state = (t_tokenizer_state){
		.ptr = p,
		.current_pos = 0,
		.quote_level = 0,
		.escape_next = 0,
		.current_token_size = 10
	};
	state->current_token = ft_calloc(state->current_token_size, sizeof(char));
	state->expmap = ft_calloc(state->current_token_size, sizeof(char));
	if (!state->current_token || !state->expmap)
	{
		free(state->current_token);
		free(state->expmap);
		ft_error_exit("malloc");
	}
}

void	process_char(t_minishell *m, t_tokenizer_state *s)
{
	if (s->escape_next)
	{
		handle_escape_char(s);
		s->escape_next = 0;
	}
	else if (*s->ptr == '\\')
		handle_backslash(s);
	else if (*s->ptr == '\'' && s->quote_level != 2)
		handle_single_quote(s);
	else if (*s->ptr == '"' && s->quote_level != 1)
		handle_double_quote(s);
	else if (ft_isspace(*s->ptr) && s->quote_level == 0)
		handle_space(m, s);
	else if (*s->ptr == '|' && s->quote_level == 0)
		handle_pipe(m, s);
	else if ((*s->ptr == '>' || *s->ptr == '<') && s->quote_level == 0)
		handle_redirection(m, s);
	else
		handle_regular_char(s);
}

void cleanup_tokenizer_state(t_tokenizer_state *state)
{
    if (state->current_token) {
        free(state->current_token);  // Freigabe des aktuellen Tokens
    }
    if (state->expmap) {
        free(state->expmap);  // Freigabe der Expansionsmap
    }
}
void handle_error_and_cleanup(t_tokenizer_state *state, t_minishell *m)
{
    cleanup_tokenizer_state(state);  // Freigabe der in state allokierten Speicher
    mlstclear(m->tok_lst);
}
void prompt_to_token(t_minishell *m)
{
    t_tokenizer_state state;
    init_tokenizer_state(&state, m->prompt);

    while (*state.ptr)
    {
        process_char(m, &state);
        if (state.current_pos >= state.current_token_size - 1)
            resize_token_buffers(&state);
    }

    // Finale Tokenisierung direkt im Hauptloop
    if (state.current_pos > 0)
    {
        state.current_token[state.current_pos] = '\0';
        state.expmap[state.current_pos] = '\0';
        t_token *token = create_token(state.current_token, state.expmap);
        if (!token)  // Prüfe, ob Token erstellt wurde
        {
            cleanup_tokenizer_state(&state);
            ft_error_exit("Fehler beim Erstellen des Tokens");  // Bei Fehlern sauber abbrechen
        }
        update_tok_type(token, WORD);
        add_token_to_list(&(m->tok_lst), token);
    }

    cleanup_tokenizer_state(&state);  // Freigabe des Tokenizers
}


#include "./../include/minishell.h"

void	ft_envlstclear(t_minishell *minishell)
{
	t_envlst	*current;
	t_envlst	*next;

	if (minishell == NULL || minishell->env_list == NULL)
		return ;
	current = minishell->env_list;
	while (current != NULL)
	{
		next = current->next;
		if (current->name)
			free(current->name);
		if (current->value)
			free(current->value);
		free(current);
		current = next;
	}
	minishell->env_list = NULL;
}

// Cleanup the minishell struct
void free_token_list(t_list *list)
{
    t_list *current = list;
    while (current)
    {
        t_list *next = current->next;
        t_token *token = current->content;

        if (token != NULL) {
            newfree_token(token);  // Token vollständig freigeben
        }

        free(current);  // Freigeben der Listenknoten
        current = next;
    }
}

void clear_cmd_seqs(t_minishell *minishell)
{
    for (int i = 0; i < MAXPIPS; i++)
    {
        if (minishell->cmd_seqs[i])
        {
            free_token_list(minishell->cmd_seqs[i]);
            minishell->cmd_seqs[i] = NULL;
        }
    }
}

void clear_exec_seqs(t_minishell *minishell)
{
    for (int i = 0; i < MAXPIPS; i++)
    {
        if (minishell->exec_seqs[i])
        {
            free_token_list(minishell->exec_seqs[i]);
            minishell->exec_seqs[i] = NULL;
        }
    }
}

void cleanup_minishell(t_minishell *minishell)
{
    reset_minishell_args(minishell);
    mlstclear(minishell->exec_lst);
    mlstclear(minishell->tok_lst);
    ft_envlstclear(minishell);
	if(minishell->pids)
   		free(minishell->pids);
    clear_cmd_seqs(minishell);
    clear_exec_seqs(minishell);
}

// Initialize the minishell struct
void	initialize_minishell(t_minishell *minishell, char **envp)
{
	minishell->leave = 0;
	minishell->last_exitcode = 0;
	minishell->exitcode = 0;
	minishell->envp = envp;
	minishell->prompt = NULL;
}


#include "./../include/minishell.h"

void reset_minishell_args(t_minishell *m)
{
    int i;

    i = 0;
    while (i < MAXPIPS)
    {
        if (m->args[i] != NULL)
        {
            free(m->args[i]);  // Free the string if it's not NULL
            m->args[i] = NULL;
        }
        i++;
    }
    m->argc = 0;
}
void mlstclear(t_list *list)
{
    t_list *current;
    t_list *next;
    t_token *token;
	ft_printf("start mlstclear\n");
    current = list;
    while (current != NULL)
    {
        next = current->next;
        token = (t_token *)current->content;
        if (token != NULL)
        {
	ft_printf("free token\n");
			if (token->str)
			{
	ft_printf("free token str\n");
            	free(token->str);
				token->str = NULL;
			}
			if (token->expmap)
			{
	ft_printf("free token expmap\n");
            	free(token->expmap);
				token->expmap = NULL;
			}
			if (token->rdrcmeta)
			{
	ft_printf("free token rdrcmeta\n");
            	free(token->rdrcmeta);
				token->rdrcmeta = NULL;
			}
			if (token->rdrctarget)
			{
	ft_printf("free token rdrctarget\n");
            	free(token->rdrctarget);
				token->rdrctarget = NULL;
			}
            free(token);
			token = NULL;
        }
		if (current != NULL)
		{
        	free(current);
			current = NULL;
		}
        current = next;
    }
	ft_printf("end mlstclear\n");
}

// Function that defines the interactive mode
static void	interactive_mode(t_minishell *minishell)
{
	int	tty_fd;

	tty_fd = open("/dev/tty", O_RDWR);
	if (tty_fd == -1)
	{
		perror("Failed to open /dev/tty");
		exit(1);
	}
	if (dup2(tty_fd, STDIN_FILENO) == -1)
	{
		perror("Failed to redirect stdin");
		exit(1);
	}
	close(tty_fd);
	if (minishell->modus == 1)
		minishell->prompt = readline("🍕🚀🌈🦄🍺 ");
	if (!minishell->prompt && g_global == 0)
	{
		exit(0);
	}
	g_global = 0;
}

// Function that defines the non-interactive mode
static void	non_interactive_mode(t_minishell *minishell)
{
	char	*input;
	char	*temp;

	temp = NULL;
	input = NULL;
	temp = get_next_line(STDIN_FILENO);
	if (temp)
	{
		input = remove_chars(temp, "\n");
		free(temp);
	}
	minishell->prompt = input;
	return ;
}

int	is_only_whitespace(const char *str)
{
	while (*str)
	{
		if (!ft_isspace((unsigned char)*str))
			return (0);
		str++;
	}
	return (1);
}

// Function that handles the input from the user or the script
static int	handle_input(t_minishell *minishell)
{
	if (minishell->modus > 0)
		interactive_mode(&(*minishell));
	else if (minishell->modus == 0)
		non_interactive_mode(&(*minishell));
	if (minishell->prompt == NULL)
		return (1);
	minishell->tok_lst = NULL;
	minishell->exec_lst = NULL;
	minishell->pids = NULL;
	minishell->argc = 0;
	if (minishell->prompt)
	{
		minishell->last_exitcode = minishell->exitcode;
		minishell->leave = 0;
		lex_prompt(minishell);
		pre_exec_prep(minishell);
		pre_exec_checks(minishell);
		if (!minishell->leave)
		{
			execute(minishell);
		}
		if (minishell->modus && *minishell->prompt
			&& !is_only_whitespace(minishell->prompt))
			add_history(minishell->prompt);
	}
	return (0);
}

int	g_global = 0;

int	main(int argc, char **argv, char **envp)
{
	t_minishell	minishell;
	g_global = 0;
	minishell.env_list = NULL;
	init_env_list(envp, &minishell);
	setup_signals(&minishell);
	initialize_minishell(&minishell, envp);
	if (argc >= 2)
	{
		if (access(argv[1], F_OK) == -1)
		{
			ft_printf("bash: %s: No such file or directory\n", argv[1]);
			minishell.last_exitcode = 127;
			minishell.leave = 1;
		}
	}
	while (1)
		if (handle_input(&minishell))
			break ;
	rl_clear_history();
	cleanup_minishell(&minishell);
	return (minishell.exitcode);
}


#include "./../include/minishell.h"


#include "./../include/minishell.h"

// Function to free a token
void split_pipes(t_minishell *m)
{
    t_list *current;
    t_list *temp_list = NULL;
    int pipe_index = 0;

    // Initialisiere cmd_seqs mit NULL
    for (int i = 0; i < 1024; i++)
    {
        m->cmd_seqs[i] = NULL;
    }

    current = m->tok_lst;
    m->pipes = 0;

    while (current != NULL)
    {
        t_token *token = (t_token *)current->content;

        if (token->token == PIPE)
        {
            if (temp_list != NULL)
            {
                m->cmd_seqs[pipe_index] = temp_list;
                temp_list = NULL;
                pipe_index++;
            }
            m->pipes++;
        }
        else
        {
            // Duplizieren des Tokens vor dem Hinzufügen zur temporären Liste
            t_token *token_dup = duplicate(token);
            if (!token_dup)
                ft_error_exit("token_dup");

            t_list *new_node = ft_lstnew(token_dup);
            if (!new_node)
            {
                // Falls Listenknoten-Erstellung fehlschlägt
                newfree_token(token_dup);  // Freigeben des duplizierten Tokens
                ft_error_exit("ft_lstnew");
            }
            ft_lstadd_back(&temp_list, new_node);
        }

        current = current->next;
    }

    // Hinzufügen der letzten Liste, falls vorhanden
    if (temp_list != NULL)
    {
        m->cmd_seqs[pipe_index] = temp_list;
    }
}


#include "./../include/minishell.h"

// Function that removes characters from a string
// str = string to remove chars from
// chrs_to_rmv = chars to remove from str
char	*remove_chars(const char *s, const char *chrs_to_rmv)
{
	int		count;
	char	*new_str;

	count = count_relevant_chars(s, chrs_to_rmv);
	new_str = (char *)malloc(sizeof(char) * (count + 1));
	if (new_str == NULL)
		exit(EXIT_FAILURE);
	remove_helper(s, chrs_to_rmv, new_str);
	return (new_str);
}

// Function that counts the number of relevant characters in a string
int	count_relevant_chars(const char *str, const char *chrs_to_rmv)
{
	int	i;
	int	j;
	int	count;

	i = 0;
	count = 0;
	while (str[i] != '\0')
	{
		j = 0;
		while (chrs_to_rmv[j] != '\0' && str[i] != chrs_to_rmv[j])
			j++;
		if (chrs_to_rmv[j] == '\0')
			count++;
		i++;
	}
	return (count);
}

// Function that removes characters from a string
void	remove_helper(const char *str, const char *chrs_to_rmv, char *new_s)
{
	int	i;
	int	j;
	int	k;

	i = 0;
	k = 0;
	while (str[i] != '\0')
	{
		j = 0;
		while (chrs_to_rmv[j] != '\0' && str[i] != chrs_to_rmv[j])
			j++;
		if (chrs_to_rmv[j] == '\0')
		{
			new_s[k] = str[i];
			k++;
		}
		i++;
	}
	new_s[k] = '\0';
}


#include "./../include/minishell.h"

// Function the main process signal
void	handle_main_process(int sig)
{
	if (sig == SIGINT)
	{
		write(STDOUT_FILENO, "\n", 1);
		rl_on_new_line();
		rl_replace_line("", 0);
		rl_redisplay();
	}
	else if (sig == SIGQUIT)
		signal(SIGQUIT, SIG_IGN);
}

// Function that handles every child process signal
void	handle_child_process(int sig)
{
	if (sig == SIGINT)
		write(STDOUT_FILENO, "", 1);
	else if (sig == SIGQUIT)
	{
		write(STDOUT_FILENO, "Quit: 3\n", 8);
		exit(131);
	}
}

void	setup_signals(t_minishell *minishell)
{
	struct sigaction	sa;
	struct termios		tty;

	tcgetattr(STDIN_FILENO, &tty);
	tty.c_lflag &= ~ECHOCTL;
	tcsetattr(STDIN_FILENO, TCSANOW, &tty);
	minishell->modus = isatty(STDIN_FILENO);
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	if (minishell->modus)
	{
		sa.sa_handler = handle_main_process;
		sigaction(SIGINT, &sa, NULL);
		sigaction(SIGQUIT, &sa, NULL);
	}
	else
	{
		sa.sa_handler = handle_child_process;
		sigaction(SIGINT, &sa, NULL);
		sigaction(SIGQUIT, &sa, NULL);
	}
}

void	reset_signals(void)
{
	struct termios	tty;

	tcgetattr(STDIN_FILENO, &tty);
	tty.c_lflag |= ECHOCTL;
	tcsetattr(STDIN_FILENO, TCSANOW, &tty);
}

void	handle_heredoc_signal(int sig)
{
	if (sig == SIGINT)
	{
		write(STDOUT_FILENO, "\n", 1);
		rl_replace_line("", 0);
		close(STDIN_FILENO);
	}
}


#include "./../../include/minishell.h"

void	free_if_not_null(void **ptr)
{
	if (*ptr)
	{
		free(*ptr);
		*ptr = NULL;
	}
}

void	free_token(void *n)
{
	t_token	*token;

	token = (t_token *)n;
	if (!token || token->is_freed)
		return ;
	free_if_not_null((void **)&token->str);
	free_if_not_null((void **)&token->rdrcmeta);
	free_if_not_null((void **)&token->rdrctarget);
	free_if_not_null((void **)&token->expmap);
	token->is_freed = 1;
}

void	update_tok_type(t_token *tok, enum e_toktype token)
{
	tok->token = token;
}

void	update_tok_type_next_word(t_list *current, enum e_toktype token)
{
	t_token	*tok;

	if (current->next != NULL)
	{
		current = current->next;
	}
	tok = (t_token *)current->content;
	if (tok->token == WORD)
	{
		tok->token = token;
	}
}

void	update_tok_type_next(t_list *current, enum e_toktype token)
{
	t_token	*tok;

	if (current->next != NULL)
	{
		current = current->next;
	}
	tok = (t_token *)current->content;
	tok->token = token;
}


#include "./../../include/minishell.h"

void	free_token_resources(t_token *newtok)
{
	if (newtok->str)
		free(newtok->str);
	free(newtok);
}

t_token	*create_token(char *str, char *expmap)
{
	t_token	*newtok;

	if (!validate_input(str, expmap))
		return (NULL);
	newtok = (t_token *)malloc(sizeof(t_token));
	if (!newtok)
		return (NULL);
	newtok->token = WORD;
	newtok->is_freed = 0;
	newtok->str = ft_strdup(str);
	if (!newtok->str)
		return (free(newtok), NULL);
	newtok->expmap = ft_strdup(expmap);
	if (!newtok->expmap)
	{
		free(newtok->str);
		free(newtok);
		return (NULL);
	}
	newtok->rdrcmeta = NULL;
	newtok->rdrctarget = NULL;
	newtok->had_quote = (ft_strchr(str, '\"') || ft_strchr(str, '\''));
	return (newtok);
}

void	print_toktype(enum e_toktype token)
{
	if (token == REDIRECTION)
		ft_printf("Redirection");
	else if (token == PIPE)
		ft_printf("Pipe");
	else if (token == COMMAND)
		ft_printf("Command");
	else if (token == WORD)
		ft_printf("Word");
	else if (token == MINIFILE)
		ft_printf("File");
	else if (token == DELIMITER)
		ft_printf("Delimiter");
	else if (token == UNSET)
		ft_printf("UNSET");
	else
		ft_printf("Unknown");
}


#include "./../../include/minishell.h"

void	put_token(void *content)
{
	t_token		*token;

	token = (t_token *)content;
	if (token != NULL)
	{
		ft_printf("token: %p ", token);
		ft_printf(Y"["D);
		ft_printf(C);
		print_toktype(token->token);
		ft_printf(" "D);
		ft_printf("%s ", token->str);
		ft_printf("%p ", token->str);
		ft_printf("map: %s ", token->expmap);
		ft_printf("%p ", token->expmap);
		ft_printf(Y"]"D);
	}
	else
	{
		ft_printf(Y"["D);
		ft_printf("(null)");
		ft_printf(Y"]"D);
	}
}

t_token	tok_lst_get(void *n)
{
	return (*(t_token *)n);
}


#include "./../../include/minishell.h"

int	validate_input(const char *str, const char *expmap)
{
	return (str && *str && expmap && *expmap);
}


#include "./../include/minishell.h"

void	reduce_internal_whitespace(const char *str, char *new_str)
{
	int	i;
	int	j;
	int	in_whitespace;

	i = 0;
	j = 0;
	in_whitespace = 0;
	while (str[i] != '\0')
	{
		if (isspace(str[i]))
		{
			if (!in_whitespace)
			{
				new_str[j++] = ' ';
				in_whitespace = 1;
			}
		}
		else
		{
			new_str[j++] = str[i];
			in_whitespace = 0;
		}
		i++;
	}
	new_str[j] = '\0';
}

char	*whitespace_handler(const char *str)
{
	char	*new_str;
	int		new_str_len;

	new_str_len = strlen(str) + 1;
	new_str = malloc(new_str_len);
	if (new_str == NULL)
	{
		return (NULL);
	}
	reduce_internal_whitespace(str, new_str);
	return (new_str);
}

